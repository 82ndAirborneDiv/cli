// Code generated by go-swagger; DO NOT EDIT.

package headchef_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1BuildRequest Build Request V1
//
// A build request (v1) which is submitted to the Head Chef REST API.
// swagger:model v1BuildRequest
type V1BuildRequest struct {

	// The version of camel to use when running setup-builds.pl. NOTE: this is temporary until the camel version is included in the recipe.
	// Required: true
	CamelCommit *string `json:"camel_commit"`

	// A list of additional command-line parameters to pass to setup-builds.pl. NOTE: this is a temporary feature to expose some camel features before build options are implemented.
	// Unique: true
	CamelFlags []string `json:"camel_flags"`

	// format
	// Required: true
	// Enum: [7zip dmg msi raw tarball zip]
	Format *string `json:"format"`

	// recipe
	// Required: true
	Recipe *V1BuildRequestRecipe `json:"recipe"`

	// requester
	Requester *Requester `json:"requester,omitempty"`
}

// Validate validates this v1 build request
func (m *V1BuildRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCamelCommit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCamelFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipe(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequester(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequest) validateCamelCommit(formats strfmt.Registry) error {

	if err := validate.Required("camel_commit", "body", m.CamelCommit); err != nil {
		return err
	}

	return nil
}

var v1BuildRequestCamelFlagsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["--dynamic-core","--python-debug","--tcl-debug","--tcl-disable-threads"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestCamelFlagsItemsEnum = append(v1BuildRequestCamelFlagsItemsEnum, v)
	}
}

func (m *V1BuildRequest) validateCamelFlagsItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestCamelFlagsItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequest) validateCamelFlags(formats strfmt.Registry) error {

	if swag.IsZero(m.CamelFlags) { // not required
		return nil
	}

	if err := validate.UniqueItems("camel_flags", "body", m.CamelFlags); err != nil {
		return err
	}

	for i := 0; i < len(m.CamelFlags); i++ {

		// value enum
		if err := m.validateCamelFlagsItemsEnum("camel_flags"+"."+strconv.Itoa(i), "body", m.CamelFlags[i]); err != nil {
			return err
		}

	}

	return nil
}

var v1BuildRequestTypeFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["7zip","dmg","msi","raw","tarball","zip"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestTypeFormatPropEnum = append(v1BuildRequestTypeFormatPropEnum, v)
	}
}

const (

	// V1BuildRequestFormatNr7zip captures enum value "7zip"
	V1BuildRequestFormatNr7zip string = "7zip"

	// V1BuildRequestFormatDmg captures enum value "dmg"
	V1BuildRequestFormatDmg string = "dmg"

	// V1BuildRequestFormatMsi captures enum value "msi"
	V1BuildRequestFormatMsi string = "msi"

	// V1BuildRequestFormatRaw captures enum value "raw"
	V1BuildRequestFormatRaw string = "raw"

	// V1BuildRequestFormatTarball captures enum value "tarball"
	V1BuildRequestFormatTarball string = "tarball"

	// V1BuildRequestFormatZip captures enum value "zip"
	V1BuildRequestFormatZip string = "zip"
)

// prop value enum
func (m *V1BuildRequest) validateFormatEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestTypeFormatPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequest) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("format", "body", m.Format); err != nil {
		return err
	}

	// value enum
	if err := m.validateFormatEnum("format", "body", *m.Format); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequest) validateRecipe(formats strfmt.Registry) error {

	if err := validate.Required("recipe", "body", m.Recipe); err != nil {
		return err
	}

	if m.Recipe != nil {
		if err := m.Recipe.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildRequest) validateRequester(formats strfmt.Registry) error {

	if swag.IsZero(m.Requester) { // not required
		return nil
	}

	if m.Requester != nil {
		if err := m.Requester.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("requester")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequest) UnmarshalBinary(b []byte) error {
	var res V1BuildRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipe Recipe
//
// A recipe contains all required information (ingredient versions, platform, build options, etc.) to build a project for a single platform.
// swagger:model V1BuildRequestRecipe
type V1BuildRequestRecipe struct {

	// Build options that are passed to the build engine
	// Unique: true
	BuildOptions []*V1BuildRequestRecipeBuildOptionsItems0 `json:"build_options"`

	// Camel-specific flags for controlling the build.
	CamelFlags interface{} `json:"camel_flags,omitempty"`

	// Image
	//
	// The full image data model
	// Required: true
	Image struct {

		// image id
		// Required: true
		// Format: uuid
		ImageID *strfmt.UUID `json:"image_id"`

		// links
		// Required: true
		Links *V1BuildRequestRecipeImageAO0Links `json:"links"`

		V1BuildRequestRecipeImageAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"image"`

	// platform
	// Required: true
	Platform *V1BuildRequestRecipePlatform `json:"platform"`

	// This recipe's ID. Identical recipes will have the same ID.
	// Required: true
	// Format: uuid
	RecipeID *strfmt.UUID `json:"recipe_id"`

	// The resolved ingredients that comprise this recipe.
	// Required: true
	// Min Items: 1
	// Unique: true
	ResolvedIngredients []*V1BuildRequestRecipeResolvedIngredientsItems0 `json:"resolved_ingredients"`
}

// Validate validates this v1 build request recipe
func (m *V1BuildRequestRecipe) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatform(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolvedIngredients(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipe) validateBuildOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildOptions) { // not required
		return nil
	}

	if err := validate.UniqueItems("recipe"+"."+"build_options", "body", m.BuildOptions); err != nil {
		return err
	}

	for i := 0; i < len(m.BuildOptions); i++ {
		if swag.IsZero(m.BuildOptions[i]) { // not required
			continue
		}

		if m.BuildOptions[i] != nil {
			if err := m.BuildOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recipe" + "." + "build_options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipe) validateImage(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"image"+"."+"image_id", "body", m.Image.ImageID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"image"+"."+"image_id", "body", "uuid", m.Image.ImageID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"image"+"."+"links", "body", m.Image.Links); err != nil {
		return err
	}

	if m.Image.Links != nil {
		if err := m.Image.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "image" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("recipe"+"."+"image"+"."+"revision", "body", m.Image.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("recipe"+"."+"image"+"."+"revision", "body", int64(*m.Image.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"image"+"."+"revision_timestamp", "body", m.Image.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"image"+"."+"revision_timestamp", "body", "date-time", m.Image.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipe) validatePlatform(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform", "body", m.Platform); err != nil {
		return err
	}

	if m.Platform != nil {
		if err := m.Platform.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildRequestRecipe) validateRecipeID(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"recipe_id", "body", m.RecipeID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"recipe_id", "body", "uuid", m.RecipeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipe) validateResolvedIngredients(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"resolved_ingredients", "body", m.ResolvedIngredients); err != nil {
		return err
	}

	iResolvedIngredientsSize := int64(len(m.ResolvedIngredients))

	if err := validate.MinItems("recipe"+"."+"resolved_ingredients", "body", iResolvedIngredientsSize, 1); err != nil {
		return err
	}

	if err := validate.UniqueItems("recipe"+"."+"resolved_ingredients", "body", m.ResolvedIngredients); err != nil {
		return err
	}

	for i := 0; i < len(m.ResolvedIngredients); i++ {
		if swag.IsZero(m.ResolvedIngredients[i]) { // not required
			continue
		}

		if m.ResolvedIngredients[i] != nil {
			if err := m.ResolvedIngredients[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recipe" + "." + "resolved_ingredients" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipe) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipe) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipe
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeBuildOptionsItems0 Recipe Build Option
//
// A global build option for a selected for a build in a recipe
// swagger:model V1BuildRequestRecipeBuildOptionsItems0
type V1BuildRequestRecipeBuildOptionsItems0 struct {

	// description
	// Required: true
	Description *string `json:"description"`

	// selected value
	// Required: true
	SelectedValue *V1BuildRequestRecipeBuildOptionsItems0SelectedValue `json:"selected_value"`

	// title
	// Required: true
	Title *string `json:"title"`
}

// Validate validates this v1 build request recipe build options items0
func (m *V1BuildRequestRecipeBuildOptionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelectedValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeBuildOptionsItems0) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeBuildOptionsItems0) validateSelectedValue(formats strfmt.Registry) error {

	if err := validate.Required("selected_value", "body", m.SelectedValue); err != nil {
		return err
	}

	if m.SelectedValue != nil {
		if err := m.SelectedValue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("selected_value")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildRequestRecipeBuildOptionsItems0) validateTitle(formats strfmt.Registry) error {

	if err := validate.Required("title", "body", m.Title); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeBuildOptionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeBuildOptionsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeBuildOptionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeBuildOptionsItems0SelectedValue v1 build request recipe build options items0 selected value
// swagger:model V1BuildRequestRecipeBuildOptionsItems0SelectedValue
type V1BuildRequestRecipeBuildOptionsItems0SelectedValue struct {

	// camel flag
	// Required: true
	CamelFlag *string `json:"camel_flag"`

	// is default
	// Required: true
	IsDefault *bool `json:"is_default"`

	// value
	// Required: true
	Value *string `json:"value"`
}

// Validate validates this v1 build request recipe build options items0 selected value
func (m *V1BuildRequestRecipeBuildOptionsItems0SelectedValue) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCamelFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefault(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeBuildOptionsItems0SelectedValue) validateCamelFlag(formats strfmt.Registry) error {

	if err := validate.Required("selected_value"+"."+"camel_flag", "body", m.CamelFlag); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeBuildOptionsItems0SelectedValue) validateIsDefault(formats strfmt.Registry) error {

	if err := validate.Required("selected_value"+"."+"is_default", "body", m.IsDefault); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeBuildOptionsItems0SelectedValue) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("selected_value"+"."+"value", "body", m.Value); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeBuildOptionsItems0SelectedValue) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeBuildOptionsItems0SelectedValue) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeBuildOptionsItems0SelectedValue
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeImageAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipeImageAO0Links
type V1BuildRequestRecipeImageAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe image a o0 links
func (m *V1BuildRequestRecipeImageAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeImageAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"image"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"image"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeImageAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeImageAllOf1 Image Core
//
// The properties of an image needed to create a new one
// swagger:model V1BuildRequestRecipeImageAllOf1
type V1BuildRequestRecipeImageAllOf1 struct {

	// The name of the image (excluding any version information). This will be something like "activestate/centos-6.9-build" (for a Docker image) or "ami-foo-12345" (WindowsInstance).
	// Required: true
	Name *string `json:"name"`

	// The platform to which this image belongs.
	// Required: true
	PlatformID *string `json:"platform_id"`

	// The type of the image.
	// Required: true
	// Enum: [Docker WindowsInstance]
	Type *string `json:"type"`

	V1BuildRequestRecipeImageAllOf1AllOf1
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipeImageAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	m.PlatformID = dataAO0.PlatformID

	m.Type = dataAO0.Type

	// AO1
	var aO1 V1BuildRequestRecipeImageAllOf1AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1BuildRequestRecipeImageAllOf1AllOf1 = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipeImageAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}

	dataAO0.Name = m.Name

	dataAO0.PlatformID = m.PlatformID

	dataAO0.Type = m.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1BuildRequestRecipeImageAllOf1AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe image all of1
func (m *V1BuildRequestRecipeImageAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1BuildRequestRecipeImageAllOf1AllOf1
	if err := m.V1BuildRequestRecipeImageAllOf1AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	return nil
}

var v1BuildRequestRecipeImageAllOf1TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Docker","WindowsInstance"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeImageAllOf1TypeTypePropEnum = append(v1BuildRequestRecipeImageAllOf1TypeTypePropEnum, v)
	}
}

// property enum
func (m *V1BuildRequestRecipeImageAllOf1) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeImageAllOf1TypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeImageAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeImageAllOf1AllOf1 Image Revision Core
//
// The properties of an image revision needed to create a new one
// swagger:model V1BuildRequestRecipeImageAllOf1AllOf1
type V1BuildRequestRecipeImageAllOf1AllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`

	// conditions
	Conditions []*V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0 `json:"conditions"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipeImageAllOf1AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	// AO2
	var dataAO2 struct {
		Conditions []*V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Conditions = dataAO2.Conditions

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipeImageAllOf1AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	var dataAO2 struct {
		Conditions []*V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}

	dataAO2.Conditions = m.Conditions

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe image all of1 all of1
func (m *V1BuildRequestRecipeImageAllOf1AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1AllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeImageAllOf1AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0
type V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 build request recipe image all of1 all of1 conditions items0
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0 v1 build request recipe image all of1 all of1 conditions items0 requirements items0
// swagger:model V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0
type V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 build request recipe image all of1 all of1 conditions items0 requirements items0
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeImageAllOf1AllOf1ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0
type V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe image all of1 all of1 provided features items0
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeImageAllOf1AllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatform Platform
//
// A platform upon which a build can be built.
// swagger:model V1BuildRequestRecipePlatform
type V1BuildRequestRecipePlatform struct {

	// CPU Architecture
	//
	// The full CPU architecture data model
	// Required: true
	CPUArchitecture struct {

		// cpu architecture id
		// Required: true
		// Format: uuid
		CPUArchitectureID *strfmt.UUID `json:"cpu_architecture_id"`

		// links
		// Required: true
		Links *V1BuildRequestRecipePlatformCPUArchitectureAO0Links `json:"links"`

		V1BuildRequestRecipePlatformCPUArchitectureAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"cpu_architecture"`

	// cpu extensions
	CPUExtensions []*V1BuildRequestRecipePlatformCPUExtensionsItems0 `json:"cpu_extensions"`

	// The date and time this platform was created.
	// Required: true
	// Format: date-time
	CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

	// display name
	// Required: true
	DisplayName *string `json:"display_name"`

	// The last day on which this platform will be supported. Can be omitted if no last day has yet been determined.
	// Format: date
	EndOfSupportDate *strfmt.Date `json:"end_of_support_date,omitempty"`

	// GPU Architecture
	//
	// The full GPU architecture data model
	GpuArchitecture struct {

		// gpu architecture id
		// Required: true
		// Format: uuid
		GpuArchitectureID *strfmt.UUID `json:"gpu_architecture_id"`

		// links
		// Required: true
		Links *V1BuildRequestRecipePlatformGpuArchitectureAO0Links `json:"links"`

		V1BuildRequestRecipePlatformGpuArchitectureAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"gpu_architecture,omitempty"`

	// images
	// Required: true
	Images []*V1BuildRequestRecipePlatformImagesItems0 `json:"images"`

	// If true, the platform should be shown to the user as a selectable platform for an order. If false, the platform should be hidden from the user.
	IsUserVisible *bool `json:"is_user_visible,omitempty"`

	// Kernel
	//
	// The full kernel data model
	// Required: true
	Kernel struct {

		// kernel id
		// Required: true
		// Format: uuid
		KernelID *strfmt.UUID `json:"kernel_id"`

		// links
		// Required: true
		Links *V1BuildRequestRecipePlatformKernelAO0Links `json:"links"`

		// The name of the kernel (excluding any version information)
		// Required: true
		Name *string `json:"name"`
	} `json:"kernel"`

	// Kernel Version
	//
	// The full kernel version data model
	// Required: true
	KernelVersion struct {

		// kernel version id
		// Required: true
		// Format: uuid
		KernelVersionID *strfmt.UUID `json:"kernel_version_id"`

		// links
		// Required: true
		Links *V1BuildRequestRecipePlatformKernelVersionAO0Links `json:"links"`

		V1BuildRequestRecipePlatformKernelVersionAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"kernel_version"`

	// Libc
	//
	// The full libc data model
	Libc struct {

		// libc id
		// Required: true
		// Format: uuid
		LibcID *strfmt.UUID `json:"libc_id"`

		// links
		// Required: true
		Links *V1BuildRequestRecipePlatformLibcAO0Links `json:"links"`

		// The name of the libc (excluding any version information)
		// Required: true
		Name *string `json:"name"`
	} `json:"libc,omitempty"`

	// Libc Version
	//
	// The full libc version data model
	LibcVersion struct {

		// libc version id
		// Required: true
		// Format: uuid
		LibcVersionID *strfmt.UUID `json:"libc_version_id"`

		// links
		// Required: true
		Links *V1BuildRequestRecipePlatformLibcVersionAO0Links `json:"links"`

		V1BuildRequestRecipePlatformLibcVersionAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"libc_version,omitempty"`

	// links
	// Required: true
	Links *V1BuildRequestRecipePlatformLinks `json:"links"`

	// Operating System
	//
	// The full operating system data model
	// Required: true
	OperatingSystem struct {

		// links
		// Required: true
		Links *V1BuildRequestRecipePlatformOperatingSystemAO0Links `json:"links"`

		// operating system id
		// Required: true
		// Format: uuid
		OperatingSystemID *strfmt.UUID `json:"operating_system_id"`

		// Whether an implementation of libc is considered a core feature of the OS. This is generally true for *nix OSes and false for others.
		// Required: true
		HasLibc *bool `json:"has_libc"`

		// The name of the operating system (excluding any version information). This should be more specific than just an OS class (e.g. 'Red Star OS' rather than just 'Linux')
		// Required: true
		Name *string `json:"name"`
	} `json:"operating_system"`

	// Operating System Version
	//
	// The full operating system version data model
	// Required: true
	OperatingSystemVersion struct {

		// links
		// Required: true
		Links *V1BuildRequestRecipePlatformOperatingSystemVersionAO0Links `json:"links"`

		// operating system version id
		// Required: true
		// Format: uuid
		OperatingSystemVersionID *strfmt.UUID `json:"operating_system_version_id"`

		V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"operating_system_version"`

	// platform id
	// Required: true
	// Format: uuid
	PlatformID *strfmt.UUID `json:"platform_id"`
}

// Validate validates this v1 build request recipe platform
func (m *V1BuildRequestRecipePlatform) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPUArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCPUExtensions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndOfSupportDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKernel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKernelVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLibc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLibcVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperatingSystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperatingSystemVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatform) validateCPUArchitecture(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"cpu_architecture"+"."+"cpu_architecture_id", "body", m.CPUArchitecture.CPUArchitectureID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"cpu_architecture"+"."+"cpu_architecture_id", "body", "uuid", m.CPUArchitecture.CPUArchitectureID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"cpu_architecture"+"."+"links", "body", m.CPUArchitecture.Links); err != nil {
		return err
	}

	if m.CPUArchitecture.Links != nil {
		if err := m.CPUArchitecture.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform" + "." + "cpu_architecture" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"cpu_architecture"+"."+"revision", "body", m.CPUArchitecture.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("recipe"+"."+"platform"+"."+"cpu_architecture"+"."+"revision", "body", int64(*m.CPUArchitecture.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"cpu_architecture"+"."+"revision_timestamp", "body", m.CPUArchitecture.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"cpu_architecture"+"."+"revision_timestamp", "body", "date-time", m.CPUArchitecture.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateCPUExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.CPUExtensions) { // not required
		return nil
	}

	for i := 0; i < len(m.CPUExtensions); i++ {
		if swag.IsZero(m.CPUExtensions[i]) { // not required
			continue
		}

		if m.CPUExtensions[i] != nil {
			if err := m.CPUExtensions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recipe" + "." + "platform" + "." + "cpu_extensions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateCreationTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"creation_timestamp", "body", m.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"creation_timestamp", "body", "date-time", m.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateDisplayName(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"display_name", "body", m.DisplayName); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateEndOfSupportDate(formats strfmt.Registry) error {

	if swag.IsZero(m.EndOfSupportDate) { // not required
		return nil
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"end_of_support_date", "body", "date", m.EndOfSupportDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateGpuArchitecture(formats strfmt.Registry) error {

	if swag.IsZero(m.GpuArchitecture) { // not required
		return nil
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"gpu_architecture"+"."+"gpu_architecture_id", "body", m.GpuArchitecture.GpuArchitectureID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"gpu_architecture"+"."+"gpu_architecture_id", "body", "uuid", m.GpuArchitecture.GpuArchitectureID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"gpu_architecture"+"."+"links", "body", m.GpuArchitecture.Links); err != nil {
		return err
	}

	if m.GpuArchitecture.Links != nil {
		if err := m.GpuArchitecture.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform" + "." + "gpu_architecture" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"gpu_architecture"+"."+"revision", "body", m.GpuArchitecture.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("recipe"+"."+"platform"+"."+"gpu_architecture"+"."+"revision", "body", int64(*m.GpuArchitecture.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"gpu_architecture"+"."+"revision_timestamp", "body", m.GpuArchitecture.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"gpu_architecture"+"."+"revision_timestamp", "body", "date-time", m.GpuArchitecture.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateImages(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"images", "body", m.Images); err != nil {
		return err
	}

	for i := 0; i < len(m.Images); i++ {
		if swag.IsZero(m.Images[i]) { // not required
			continue
		}

		if m.Images[i] != nil {
			if err := m.Images[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recipe" + "." + "platform" + "." + "images" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateKernel(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"kernel"+"."+"kernel_id", "body", m.Kernel.KernelID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"kernel"+"."+"kernel_id", "body", "uuid", m.Kernel.KernelID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"kernel"+"."+"links", "body", m.Kernel.Links); err != nil {
		return err
	}

	if m.Kernel.Links != nil {
		if err := m.Kernel.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform" + "." + "kernel" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"kernel"+"."+"name", "body", m.Kernel.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateKernelVersion(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"kernel_version"+"."+"kernel_version_id", "body", m.KernelVersion.KernelVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"kernel_version"+"."+"kernel_version_id", "body", "uuid", m.KernelVersion.KernelVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"kernel_version"+"."+"links", "body", m.KernelVersion.Links); err != nil {
		return err
	}

	if m.KernelVersion.Links != nil {
		if err := m.KernelVersion.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform" + "." + "kernel_version" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"kernel_version"+"."+"revision", "body", m.KernelVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("recipe"+"."+"platform"+"."+"kernel_version"+"."+"revision", "body", int64(*m.KernelVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"kernel_version"+"."+"revision_timestamp", "body", m.KernelVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"kernel_version"+"."+"revision_timestamp", "body", "date-time", m.KernelVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateLibc(formats strfmt.Registry) error {

	if swag.IsZero(m.Libc) { // not required
		return nil
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"libc"+"."+"libc_id", "body", m.Libc.LibcID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"libc"+"."+"libc_id", "body", "uuid", m.Libc.LibcID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"libc"+"."+"links", "body", m.Libc.Links); err != nil {
		return err
	}

	if m.Libc.Links != nil {
		if err := m.Libc.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform" + "." + "libc" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"libc"+"."+"name", "body", m.Libc.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateLibcVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.LibcVersion) { // not required
		return nil
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"libc_version"+"."+"libc_version_id", "body", m.LibcVersion.LibcVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"libc_version"+"."+"libc_version_id", "body", "uuid", m.LibcVersion.LibcVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"libc_version"+"."+"links", "body", m.LibcVersion.Links); err != nil {
		return err
	}

	if m.LibcVersion.Links != nil {
		if err := m.LibcVersion.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform" + "." + "libc_version" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"libc_version"+"."+"revision", "body", m.LibcVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("recipe"+"."+"platform"+"."+"libc_version"+"."+"revision", "body", int64(*m.LibcVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"libc_version"+"."+"revision_timestamp", "body", m.LibcVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"libc_version"+"."+"revision_timestamp", "body", "date-time", m.LibcVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform" + "." + "links")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateOperatingSystem(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system"+"."+"links", "body", m.OperatingSystem.Links); err != nil {
		return err
	}

	if m.OperatingSystem.Links != nil {
		if err := m.OperatingSystem.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform" + "." + "operating_system" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system"+"."+"operating_system_id", "body", m.OperatingSystem.OperatingSystemID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"operating_system"+"."+"operating_system_id", "body", "uuid", m.OperatingSystem.OperatingSystemID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system"+"."+"has_libc", "body", m.OperatingSystem.HasLibc); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system"+"."+"name", "body", m.OperatingSystem.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validateOperatingSystemVersion(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system_version"+"."+"links", "body", m.OperatingSystemVersion.Links); err != nil {
		return err
	}

	if m.OperatingSystemVersion.Links != nil {
		if err := m.OperatingSystemVersion.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe" + "." + "platform" + "." + "operating_system_version" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system_version"+"."+"operating_system_version_id", "body", m.OperatingSystemVersion.OperatingSystemVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"operating_system_version"+"."+"operating_system_version_id", "body", "uuid", m.OperatingSystemVersion.OperatingSystemVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system_version"+"."+"revision", "body", m.OperatingSystemVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("recipe"+"."+"platform"+"."+"operating_system_version"+"."+"revision", "body", int64(*m.OperatingSystemVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system_version"+"."+"revision_timestamp", "body", m.OperatingSystemVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"operating_system_version"+"."+"revision_timestamp", "body", "date-time", m.OperatingSystemVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatform) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"platform_id", "body", "uuid", m.PlatformID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatform) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatform) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatform
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformCPUArchitectureAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformCPUArchitectureAO0Links
type V1BuildRequestRecipePlatformCPUArchitectureAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform CPU architecture a o0 links
func (m *V1BuildRequestRecipePlatformCPUArchitectureAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformCPUArchitectureAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"cpu_architecture"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"cpu_architecture"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUArchitectureAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUArchitectureAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformCPUArchitectureAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformCPUArchitectureAllOf1 CPU Architecture Core
//
// The properties of a CPU architecture needed to create a new one
// swagger:model V1BuildRequestRecipePlatformCPUArchitectureAllOf1
type V1BuildRequestRecipePlatformCPUArchitectureAllOf1 struct {

	// bit width
	// Enum: [32 64]
	BitWidth string `json:"bit_width,omitempty"`

	// The name of the CPU architecture
	// Required: true
	Name *string `json:"name"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		BitWidth string `json:"bit_width,omitempty"`

		Name *string `json:"name"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.BitWidth = dataAO0.BitWidth

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformCPUArchitectureAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		BitWidth string `json:"bit_width,omitempty"`

		Name *string `json:"name"`
	}

	dataAO0.BitWidth = m.BitWidth

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform CPU architecture all of1
func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBitWidth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildRequestRecipePlatformCpuArchitectureAllOf1TypeBitWidthPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["32","64"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipePlatformCpuArchitectureAllOf1TypeBitWidthPropEnum = append(v1BuildRequestRecipePlatformCpuArchitectureAllOf1TypeBitWidthPropEnum, v)
	}
}

// property enum
func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1) validateBitWidthEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipePlatformCpuArchitectureAllOf1TypeBitWidthPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1) validateBitWidth(formats strfmt.Registry) error {

	if swag.IsZero(m.BitWidth) { // not required
		return nil
	}

	// value enum
	if err := m.validateBitWidthEnum("bit_width", "body", m.BitWidth); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformCPUArchitectureAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0
type V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform CPU architecture all of1 provided features items0
func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformCPUArchitectureAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformCPUExtensionsItems0 CPU Extension
//
// The full CPU extension data model
// swagger:model V1BuildRequestRecipePlatformCPUExtensionsItems0
type V1BuildRequestRecipePlatformCPUExtensionsItems0 struct {

	// cpu extension id
	// Required: true
	// Format: uuid
	CPUExtensionID *strfmt.UUID `json:"cpu_extension_id"`

	// links
	// Required: true
	Links *V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links `json:"links"`

	V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1

	// The revision number of this revision of the resource. This number increases monotonically with each new revision.
	// Required: true
	// Minimum: 1
	Revision *int64 `json:"revision"`

	// The date and time at which this revision of the resource was created
	// Required: true
	// Format: date-time
	RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CPUExtensionID *strfmt.UUID `json:"cpu_extension_id"`

		Links *V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links `json:"links"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CPUExtensionID = dataAO0.CPUExtensionID

	m.Links = dataAO0.Links

	// AO1
	var aO1 V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1 = aO1

	// AO2
	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Revision = dataAO2.Revision

	m.RevisionTimestamp = dataAO2.RevisionTimestamp

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformCPUExtensionsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		CPUExtensionID *strfmt.UUID `json:"cpu_extension_id"`

		Links *V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links `json:"links"`
	}

	dataAO0.CPUExtensionID = m.CPUExtensionID

	dataAO0.Links = m.Links

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}

	dataAO2.Revision = m.Revision

	dataAO2.RevisionTimestamp = m.RevisionTimestamp

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform CPU extensions items0
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPUExtensionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1
	if err := m.V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevisionTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0) validateCPUExtensionID(formats strfmt.Registry) error {

	if err := validate.Required("cpu_extension_id", "body", m.CPUExtensionID); err != nil {
		return err
	}

	if err := validate.FormatOf("cpu_extension_id", "body", "uuid", m.CPUExtensionID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0) validateRevision(formats strfmt.Registry) error {

	if err := validate.Required("revision", "body", m.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("revision", "body", int64(*m.Revision), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0) validateRevisionTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("revision_timestamp", "body", m.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("revision_timestamp", "body", "date-time", m.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformCPUExtensionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links
type V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform CPU extensions items0 a o0 links
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformCPUExtensionsItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1 CPU Extension Core
//
// The properties of a CPU extension needed to create a new one
// swagger:model V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1
type V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1 struct {

	// The name of the CPU extension
	// Required: true
	Name *string `json:"name"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`
	}

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform CPU extensions items0 all of1
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0
type V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform CPU extensions items0 all of1 provided features items0
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformGpuArchitectureAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformGpuArchitectureAO0Links
type V1BuildRequestRecipePlatformGpuArchitectureAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform gpu architecture a o0 links
func (m *V1BuildRequestRecipePlatformGpuArchitectureAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformGpuArchitectureAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"gpu_architecture"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"gpu_architecture"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformGpuArchitectureAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformGpuArchitectureAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformGpuArchitectureAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformGpuArchitectureAllOf1 GPU Architecture Core
//
// The properties of a GPU architecture needed to create a new one
// swagger:model V1BuildRequestRecipePlatformGpuArchitectureAllOf1
type V1BuildRequestRecipePlatformGpuArchitectureAllOf1 struct {

	// The name of the GPU architecture
	// Required: true
	Name *string `json:"name"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformGpuArchitectureAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`
	}

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform gpu architecture all of1
func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformGpuArchitectureAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0
type V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform gpu architecture all of1 provided features items0
func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformGpuArchitectureAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformImagesItems0 Image
//
// The full image data model
// swagger:model V1BuildRequestRecipePlatformImagesItems0
type V1BuildRequestRecipePlatformImagesItems0 struct {

	// image id
	// Required: true
	// Format: uuid
	ImageID *strfmt.UUID `json:"image_id"`

	// links
	// Required: true
	Links *V1BuildRequestRecipePlatformImagesItems0AO0Links `json:"links"`

	V1BuildRequestRecipePlatformImagesItems0AllOf1

	// The revision number of this revision of the resource. This number increases monotonically with each new revision.
	// Required: true
	// Minimum: 1
	Revision *int64 `json:"revision"`

	// The date and time at which this revision of the resource was created
	// Required: true
	// Format: date-time
	RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformImagesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		ImageID *strfmt.UUID `json:"image_id"`

		Links *V1BuildRequestRecipePlatformImagesItems0AO0Links `json:"links"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.ImageID = dataAO0.ImageID

	m.Links = dataAO0.Links

	// AO1
	var aO1 V1BuildRequestRecipePlatformImagesItems0AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1BuildRequestRecipePlatformImagesItems0AllOf1 = aO1

	// AO2
	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Revision = dataAO2.Revision

	m.RevisionTimestamp = dataAO2.RevisionTimestamp

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformImagesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		ImageID *strfmt.UUID `json:"image_id"`

		Links *V1BuildRequestRecipePlatformImagesItems0AO0Links `json:"links"`
	}

	dataAO0.ImageID = m.ImageID

	dataAO0.Links = m.Links

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1BuildRequestRecipePlatformImagesItems0AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}

	dataAO2.Revision = m.Revision

	dataAO2.RevisionTimestamp = m.RevisionTimestamp

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform images items0
func (m *V1BuildRequestRecipePlatformImagesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateImageID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1BuildRequestRecipePlatformImagesItems0AllOf1
	if err := m.V1BuildRequestRecipePlatformImagesItems0AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevisionTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0) validateImageID(formats strfmt.Registry) error {

	if err := validate.Required("image_id", "body", m.ImageID); err != nil {
		return err
	}

	if err := validate.FormatOf("image_id", "body", "uuid", m.ImageID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0) validateRevision(formats strfmt.Registry) error {

	if err := validate.Required("revision", "body", m.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("revision", "body", int64(*m.Revision), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0) validateRevisionTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("revision_timestamp", "body", m.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("revision_timestamp", "body", "date-time", m.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformImagesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformImagesItems0AO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformImagesItems0AO0Links
type V1BuildRequestRecipePlatformImagesItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform images items0 a o0 links
func (m *V1BuildRequestRecipePlatformImagesItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformImagesItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformImagesItems0AllOf1 Image Core
//
// The properties of an image needed to create a new one
// swagger:model V1BuildRequestRecipePlatformImagesItems0AllOf1
type V1BuildRequestRecipePlatformImagesItems0AllOf1 struct {

	// The name of the image (excluding any version information). This will be something like "activestate/centos-6.9-build" (for a Docker image) or "ami-foo-12345" (WindowsInstance).
	// Required: true
	Name *string `json:"name"`

	// The platform to which this image belongs.
	// Required: true
	PlatformID *string `json:"platform_id"`

	// The type of the image.
	// Required: true
	// Enum: [Docker WindowsInstance]
	Type *string `json:"type"`

	V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	m.PlatformID = dataAO0.PlatformID

	m.Type = dataAO0.Type

	// AO1
	var aO1 V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1 = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformImagesItems0AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}

	dataAO0.Name = m.Name

	dataAO0.PlatformID = m.PlatformID

	dataAO0.Type = m.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform images items0 all of1
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1
	if err := m.V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	return nil
}

var v1BuildRequestRecipePlatformImagesItems0AllOf1TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Docker","WindowsInstance"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipePlatformImagesItems0AllOf1TypeTypePropEnum = append(v1BuildRequestRecipePlatformImagesItems0AllOf1TypeTypePropEnum, v)
	}
}

// property enum
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipePlatformImagesItems0AllOf1TypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformImagesItems0AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1 Image Revision Core
//
// The properties of an image revision needed to create a new one
// swagger:model V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1
type V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`

	// conditions
	Conditions []*V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0 `json:"conditions"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	// AO2
	var dataAO2 struct {
		Conditions []*V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Conditions = dataAO2.Conditions

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	var dataAO2 struct {
		Conditions []*V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}

	dataAO2.Conditions = m.Conditions

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform images items0 all of1 all of1
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0
type V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 build request recipe platform images items0 all of1 all of1 conditions items0
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0 v1 build request recipe platform images items0 all of1 all of1 conditions items0 requirements items0
// swagger:model V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0
type V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 build request recipe platform images items0 all of1 all of1 conditions items0 requirements items0
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0
type V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform images items0 all of1 all of1 provided features items0
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformKernelAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformKernelAO0Links
type V1BuildRequestRecipePlatformKernelAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform kernel a o0 links
func (m *V1BuildRequestRecipePlatformKernelAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformKernelAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"kernel"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"kernel"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformKernelAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformKernelAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformKernelAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformKernelVersionAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformKernelVersionAO0Links
type V1BuildRequestRecipePlatformKernelVersionAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform kernel version a o0 links
func (m *V1BuildRequestRecipePlatformKernelVersionAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformKernelVersionAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"kernel_version"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"kernel_version"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformKernelVersionAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformKernelVersionAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformKernelVersionAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformKernelVersionAllOf1 Kernel Version Core
//
// The properties of a kernel version needed to create a new one
// swagger:model V1BuildRequestRecipePlatformKernelVersionAllOf1
type V1BuildRequestRecipePlatformKernelVersionAllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformKernelVersionAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform kernel version all of1
func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformKernelVersionAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0
type V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform kernel version all of1 provided features items0
func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformKernelVersionAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformLibcAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformLibcAO0Links
type V1BuildRequestRecipePlatformLibcAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform libc a o0 links
func (m *V1BuildRequestRecipePlatformLibcAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformLibcAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"libc"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"libc"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLibcAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLibcAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformLibcAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformLibcVersionAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformLibcVersionAO0Links
type V1BuildRequestRecipePlatformLibcVersionAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform libc version a o0 links
func (m *V1BuildRequestRecipePlatformLibcVersionAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformLibcVersionAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"libc_version"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"libc_version"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLibcVersionAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLibcVersionAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformLibcVersionAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformLibcVersionAllOf1 Libc Version Core
//
// The properties of a libc version needed to create a new one
// swagger:model V1BuildRequestRecipePlatformLibcVersionAllOf1
type V1BuildRequestRecipePlatformLibcVersionAllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformLibcVersionAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform libc version all of1
func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformLibcVersionAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0
type V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform libc version all of1 provided features items0
func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformLibcVersionAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformLinks Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformLinks
type V1BuildRequestRecipePlatformLinks struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform links
func (m *V1BuildRequestRecipePlatformLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformLinks) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformLinks) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformOperatingSystemAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformOperatingSystemAO0Links
type V1BuildRequestRecipePlatformOperatingSystemAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform operating system a o0 links
func (m *V1BuildRequestRecipePlatformOperatingSystemAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"operating_system"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformOperatingSystemAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformOperatingSystemAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformOperatingSystemAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformOperatingSystemVersionAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipePlatformOperatingSystemVersionAO0Links
type V1BuildRequestRecipePlatformOperatingSystemVersionAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe platform operating system version a o0 links
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform"+"."+"operating_system_version"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform"+"."+"operating_system_version"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformOperatingSystemVersionAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1 Operating System Version Core
//
// The properties of an operating system version needed to create a new one
// swagger:model V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1
type V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform operating system version all of1
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0
type V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe platform operating system version all of1 provided features items0
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipePlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0 Resolved Ingredient
//
// An ingredient that is part of a recipe's resolved requirements
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0 struct {

	// Alternative ingredient versions which can also satisfy the order's requirement. Each entry in the array is the ID of an ingredient version which could satisfy these requirements.
	Alternatives []strfmt.UUID `json:"alternatives"`

	// The custom build scripts for building this ingredient, if any
	BuildScripts []*V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0 `json:"build_scripts"`

	// This dependencies in the recipe for this ingredient version. Each item contains an ingredient version UUID which maps to an ingredient version in this recipe.
	Dependencies []*V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0 `json:"dependencies"`

	// Ingredient
	//
	// A unique ingredient that can be used in a recipe. This model contains all ingredient properties and is returned from read requests.
	// Required: true
	Ingredient struct {

		// creation timestamp
		// Required: true
		// Format: date-time
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		// ingredient id
		// Required: true
		// Format: uuid
		IngredientID *strfmt.UUID `json:"ingredient_id"`

		// links
		// Required: true
		Links *V1BuildRequestRecipeResolvedIngredientsItems0IngredientAO0Links `json:"links"`

		// A concise summary of what this ingredient can be used for
		// Required: true
		Description *string `json:"description"`

		// The name of the ingredient (excluding any version information)
		// Required: true
		Name *string `json:"name"`

		// The UUID of the organization the ingredient belongs to, if it is private to a particular organization
		// Required: true
		// Format: uuid
		OrganizationID *strfmt.UUID `json:"organization_id"`

		// The primary namespace to which this ingredient belongs
		// Required: true
		PrimaryNamespace *string `json:"primary_namespace"`

		// URL of the website about this ingredient (if any)
		// Required: true
		// Format: uri
		Website *strfmt.URI `json:"website"`
	} `json:"ingredient"`

	// Ingredient Version
	//
	// The full ingredient version data model. Returned from all read requests.
	// Required: true
	IngredientVersion struct {

		// creation timestamp
		// Required: true
		// Format: date-time
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		// ingredient id
		// Required: true
		// Format: uuid
		IngredientID *strfmt.UUID `json:"ingredient_id"`

		// ingredient version id
		// Required: true
		// Format: uuid
		IngredientVersionID *strfmt.UUID `json:"ingredient_version_id"`

		// links
		// Required: true
		Links struct {

			// The URI of this resource
			// Required: true
			// Format: uri
			Self *strfmt.URI `json:"self"`

			// The URI of the ingredient this is a version of
			// Required: true
			// Format: uri
			Ingredient *strfmt.URI `json:"ingredient"`
		} `json:"links"`

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`

		V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2

		V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3
	} `json:"ingredient_version"`

	// The patches to apply to this ingredient's source before building, if any
	Patches []*V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0 `json:"patches"`

	// The original requirement(s) in the order that were resolved to this ingredient version. This list will be empty if an ingredient was added to the recipe to fulfill a dependency of something else in the order.
	ResolvedRequirements []*V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0 `json:"resolved_requirements"`
}

// Validate validates this v1 build request recipe resolved ingredients items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlternatives(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuildScripts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredient(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePatches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolvedRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0) validateAlternatives(formats strfmt.Registry) error {

	if swag.IsZero(m.Alternatives) { // not required
		return nil
	}

	for i := 0; i < len(m.Alternatives); i++ {

		if err := validate.FormatOf("alternatives"+"."+strconv.Itoa(i), "body", "uuid", m.Alternatives[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0) validateBuildScripts(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildScripts) { // not required
		return nil
	}

	for i := 0; i < len(m.BuildScripts); i++ {
		if swag.IsZero(m.BuildScripts[i]) { // not required
			continue
		}

		if m.BuildScripts[i] != nil {
			if err := m.BuildScripts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("build_scripts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0) validateDependencies(formats strfmt.Registry) error {

	if swag.IsZero(m.Dependencies) { // not required
		return nil
	}

	for i := 0; i < len(m.Dependencies); i++ {
		if swag.IsZero(m.Dependencies[i]) { // not required
			continue
		}

		if m.Dependencies[i] != nil {
			if err := m.Dependencies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependencies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0) validateIngredient(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"creation_timestamp", "body", m.Ingredient.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"creation_timestamp", "body", "date-time", m.Ingredient.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"ingredient_id", "body", m.Ingredient.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"ingredient_id", "body", "uuid", m.Ingredient.IngredientID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"links", "body", m.Ingredient.Links); err != nil {
		return err
	}

	if m.Ingredient.Links != nil {
		if err := m.Ingredient.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingredient" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("ingredient"+"."+"description", "body", m.Ingredient.Description); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"name", "body", m.Ingredient.Name); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"organization_id", "body", m.Ingredient.OrganizationID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"organization_id", "body", "uuid", m.Ingredient.OrganizationID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"primary_namespace", "body", m.Ingredient.PrimaryNamespace); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"website", "body", m.Ingredient.Website); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"website", "body", "uri", m.Ingredient.Website.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0) validateIngredientVersion(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"creation_timestamp", "body", m.IngredientVersion.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"creation_timestamp", "body", "date-time", m.IngredientVersion.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"ingredient_id", "body", m.IngredientVersion.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"ingredient_id", "body", "uuid", m.IngredientVersion.IngredientID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"ingredient_version_id", "body", m.IngredientVersion.IngredientVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"ingredient_version_id", "body", "uuid", m.IngredientVersion.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"links"+"."+"self", "body", m.IngredientVersion.Links.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"links"+"."+"self", "body", "uri", m.IngredientVersion.Links.Self.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"links"+"."+"ingredient", "body", m.IngredientVersion.Links.Ingredient); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"links"+"."+"ingredient", "body", "uri", m.IngredientVersion.Links.Ingredient.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"revision", "body", m.IngredientVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("ingredient_version"+"."+"revision", "body", int64(*m.IngredientVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"revision_timestamp", "body", m.IngredientVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"revision_timestamp", "body", "date-time", m.IngredientVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0) validatePatches(formats strfmt.Registry) error {

	if swag.IsZero(m.Patches) { // not required
		return nil
	}

	for i := 0; i < len(m.Patches); i++ {
		if swag.IsZero(m.Patches[i]) { // not required
			continue
		}

		if m.Patches[i] != nil {
			if err := m.Patches[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0) validateResolvedRequirements(formats strfmt.Registry) error {

	if swag.IsZero(m.ResolvedRequirements) { // not required
		return nil
	}

	for i := 0; i < len(m.ResolvedRequirements); i++ {
		if swag.IsZero(m.ResolvedRequirements[i]) { // not required
			continue
		}

		if m.ResolvedRequirements[i] != nil {
			if err := m.ResolvedRequirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resolved_requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0 Build Script
//
// A short piece of scripting code that can be used to build an ingredient. This model contains all build script properties and is returned from read requests
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0 struct {

	// build script id
	// Required: true
	// Format: uuid
	BuildScriptID *strfmt.UUID `json:"build_script_id"`

	// creation timestamp
	// Required: true
	// Format: date-time
	CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

	// links
	// Required: true
	Links *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links `json:"links"`

	// The features that must already be present in the recipe for this build script to be used. For example, can be used to create build scripts that only work on specific operating systems.
	Conditions []*V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 `json:"conditions"`

	// The scripting language that the build script is written in
	// Required: true
	// Enum: [bash perl python]
	Language *string `json:"language"`

	// The build script itself
	// Required: true
	Script *string `json:"script"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		BuildScriptID *strfmt.UUID `json:"build_script_id"`

		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links `json:"links"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.BuildScriptID = dataAO0.BuildScriptID

	m.CreationTimestamp = dataAO0.CreationTimestamp

	m.Links = dataAO0.Links

	// AO1
	var dataAO1 struct {
		Conditions []*V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 `json:"conditions,omitempty"`

		Language *string `json:"language"`

		Script *string `json:"script"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Conditions = dataAO1.Conditions

	m.Language = dataAO1.Language

	m.Script = dataAO1.Script

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		BuildScriptID *strfmt.UUID `json:"build_script_id"`

		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links `json:"links"`
	}

	dataAO0.BuildScriptID = m.BuildScriptID

	dataAO0.CreationTimestamp = m.CreationTimestamp

	dataAO0.Links = m.Links

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		Conditions []*V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 `json:"conditions,omitempty"`

		Language *string `json:"language"`

		Script *string `json:"script"`
	}

	dataAO1.Conditions = m.Conditions

	dataAO1.Language = m.Language

	dataAO1.Script = m.Script

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe resolved ingredients items0 build scripts items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildScriptID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScript(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) validateBuildScriptID(formats strfmt.Registry) error {

	if err := validate.Required("build_script_id", "body", m.BuildScriptID); err != nil {
		return err
	}

	if err := validate.FormatOf("build_script_id", "body", "uuid", m.BuildScriptID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) validateCreationTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("creation_timestamp", "body", m.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("creation_timestamp", "body", "date-time", m.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0TypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bash","perl","python"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0TypeLanguagePropEnum = append(v1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0TypeLanguagePropEnum, v)
	}
}

// property enum
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) validateLanguageEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0TypeLanguagePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) validateLanguage(formats strfmt.Registry) error {

	if err := validate.Required("language", "body", m.Language); err != nil {
		return err
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", *m.Language); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) validateScript(formats strfmt.Registry) error {

	if err := validate.Required("script", "body", m.Script); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links
type V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 build scripts items0 a o0 links
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 build scripts items0 conditions items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0 v1 build request recipe resolved ingredients items0 build scripts items0 conditions items0 requirements items0
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 build scripts items0 conditions items0 requirements items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0 v1 build request recipe resolved ingredients items0 dependencies items0
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0
type V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0 struct {

	// The type or types of dependencies on this ingredient version.
	// Required: true
	// Min Items: 1
	// Unique: true
	DependencyTypes []string `json:"dependency_types"`

	// ingredient version id
	// Required: true
	// Format: uuid
	IngredientVersionID *strfmt.UUID `json:"ingredient_version_id"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 dependencies items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencyTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0DependencyTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build","runtime","test"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0DependencyTypesItemsEnum = append(v1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0DependencyTypesItemsEnum, v)
	}
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0) validateDependencyTypesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0DependencyTypesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0) validateDependencyTypes(formats strfmt.Registry) error {

	if err := validate.Required("dependency_types", "body", m.DependencyTypes); err != nil {
		return err
	}

	iDependencyTypesSize := int64(len(m.DependencyTypes))

	if err := validate.MinItems("dependency_types", "body", iDependencyTypesSize, 1); err != nil {
		return err
	}

	if err := validate.UniqueItems("dependency_types", "body", m.DependencyTypes); err != nil {
		return err
	}

	for i := 0; i < len(m.DependencyTypes); i++ {

		// value enum
		if err := m.validateDependencyTypesItemsEnum("dependency_types"+"."+strconv.Itoa(i), "body", m.DependencyTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0) validateIngredientVersionID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version_id", "body", m.IngredientVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version_id", "body", "uuid", m.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0DependenciesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0IngredientAO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0IngredientAO0Links
type V1BuildRequestRecipeResolvedIngredientsItems0IngredientAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 ingredient a o0 links
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientAO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0IngredientAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2 Ingredient Version Core
//
// The fields of an ingredient version that can be set when an ingredient version is created
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2
type V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2 struct {

	// The text from the license or elsewhere that declares the copyright holder(s) and year(s)
	// Required: true
	CopyrightText *string `json:"copyright_text"`

	// The URL of a webpage where the documentation for this ingredient version is hosted, if available
	// Format: uri
	DocumentationURI strfmt.URI `json:"documentation_uri,omitempty"`

	// Tells if this ingredient version consists of only a binary without any source.
	IsBinaryOnly *bool `json:"is_binary_only,omitempty"`

	// An SPDX 2.1 license expression describing the exact licensing for this ingredient version
	// Required: true
	LicenseExpression *string `json:"license_expression"`

	// The date and time this ingredient version was first released
	// Required: true
	// Format: date-time
	ReleaseTimestamp *strfmt.DateTime `json:"release_timestamp"`

	// The URL from which we initially retrieved the source for this ingredient version.
	// Format: uri
	SourceURI *strfmt.URI `json:"source_uri,omitempty"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CopyrightText *string `json:"copyright_text"`

		DocumentationURI strfmt.URI `json:"documentation_uri,omitempty"`

		IsBinaryOnly *bool `json:"is_binary_only,omitempty"`

		LicenseExpression *string `json:"license_expression"`

		ReleaseTimestamp *strfmt.DateTime `json:"release_timestamp"`

		SourceURI *strfmt.URI `json:"source_uri,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CopyrightText = dataAO0.CopyrightText

	m.DocumentationURI = dataAO0.DocumentationURI

	m.IsBinaryOnly = dataAO0.IsBinaryOnly

	m.LicenseExpression = dataAO0.LicenseExpression

	m.ReleaseTimestamp = dataAO0.ReleaseTimestamp

	m.SourceURI = dataAO0.SourceURI

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		CopyrightText *string `json:"copyright_text"`

		DocumentationURI strfmt.URI `json:"documentation_uri,omitempty"`

		IsBinaryOnly *bool `json:"is_binary_only,omitempty"`

		LicenseExpression *string `json:"license_expression"`

		ReleaseTimestamp *strfmt.DateTime `json:"release_timestamp"`

		SourceURI *strfmt.URI `json:"source_uri,omitempty"`
	}

	dataAO0.CopyrightText = m.CopyrightText

	dataAO0.DocumentationURI = m.DocumentationURI

	dataAO0.IsBinaryOnly = m.IsBinaryOnly

	dataAO0.LicenseExpression = m.LicenseExpression

	dataAO0.ReleaseTimestamp = m.ReleaseTimestamp

	dataAO0.SourceURI = m.SourceURI

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe resolved ingredients items0 ingredient version all of2
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCopyrightText(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocumentationURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicenseExpression(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReleaseTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) validateCopyrightText(formats strfmt.Registry) error {

	if err := validate.Required("copyright_text", "body", m.CopyrightText); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) validateDocumentationURI(formats strfmt.Registry) error {

	if swag.IsZero(m.DocumentationURI) { // not required
		return nil
	}

	if err := validate.FormatOf("documentation_uri", "body", "uri", m.DocumentationURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) validateLicenseExpression(formats strfmt.Registry) error {

	if err := validate.Required("license_expression", "body", m.LicenseExpression); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) validateReleaseTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("release_timestamp", "body", m.ReleaseTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("release_timestamp", "body", "date-time", m.ReleaseTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) validateSourceURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceURI) { // not required
		return nil
	}

	if err := validate.FormatOf("source_uri", "body", "uri", m.SourceURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf2
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3 Ingredient Version Revision Core
//
// The fields of an ingredient version that can be updated by creating a new revision
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3
type V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3 struct {

	// Camel-specific metadata needed to build this ingredient version revision in camel, if there is any.
	CamelExtras interface{} `json:"camel_extras,omitempty"`

	// dependency sets
	DependencySets []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 `json:"dependency_sets"`

	// Whether or not this is a stable release of the package
	IsStableRelease *bool `json:"is_stable_release,omitempty"`

	// S3 URL where the source distribution is stored for our platform
	// Format: uri
	PlatformSourceURI *strfmt.URI `json:"platform_source_uri,omitempty"`

	// A checksum of the source distribution. The actual type of the checksum (MD5, S3 Etag, etc.) is not specified. It's assumed that the system that populates and uses this data will know how to work with these checksums.
	SourceChecksum *string `json:"source_checksum,omitempty"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CamelExtras interface{} `json:"camel_extras,omitempty"`

		DependencySets []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 `json:"dependency_sets,omitempty"`

		IsStableRelease *bool `json:"is_stable_release,omitempty"`

		PlatformSourceURI *strfmt.URI `json:"platform_source_uri,omitempty"`

		SourceChecksum *string `json:"source_checksum,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CamelExtras = dataAO0.CamelExtras

	m.DependencySets = dataAO0.DependencySets

	m.IsStableRelease = dataAO0.IsStableRelease

	m.PlatformSourceURI = dataAO0.PlatformSourceURI

	m.SourceChecksum = dataAO0.SourceChecksum

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		CamelExtras interface{} `json:"camel_extras,omitempty"`

		DependencySets []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 `json:"dependency_sets,omitempty"`

		IsStableRelease *bool `json:"is_stable_release,omitempty"`

		PlatformSourceURI *strfmt.URI `json:"platform_source_uri,omitempty"`

		SourceChecksum *string `json:"source_checksum,omitempty"`
	}

	dataAO0.CamelExtras = m.CamelExtras

	dataAO0.DependencySets = m.DependencySets

	dataAO0.IsStableRelease = m.IsStableRelease

	dataAO0.PlatformSourceURI = m.PlatformSourceURI

	dataAO0.SourceChecksum = m.SourceChecksum

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe resolved ingredients items0 ingredient version all of3
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencySets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformSourceURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3) validateDependencySets(formats strfmt.Registry) error {

	if swag.IsZero(m.DependencySets) { // not required
		return nil
	}

	for i := 0; i < len(m.DependencySets); i++ {
		if swag.IsZero(m.DependencySets[i]) { // not required
			continue
		}

		if m.DependencySets[i] != nil {
			if err := m.DependencySets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependency_sets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3) validatePlatformSourceURI(formats strfmt.Registry) error {

	if swag.IsZero(m.PlatformSourceURI) { // not required
		return nil
	}

	if err := validate.FormatOf("platform_source_uri", "body", "uri", m.PlatformSourceURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 v1 build request recipe resolved ingredients items0 ingredient version all of3 dependency sets items0
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 struct {

	// dependencies
	// Required: true
	// Min Items: 1
	Dependencies []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0 `json:"dependencies"`

	// A description of this set.
	Description string `json:"description,omitempty"`

	// Whatever text or metadata was parsed to create this set.
	OriginalRequirement string `json:"original_requirement,omitempty"`

	// Recipe
	//
	// The different types of dependencies supported by the platform.
	// Required: true
	// Enum: [build runtime test]
	Type *string `json:"type"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 ingredient version all of3 dependency sets items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) validateDependencies(formats strfmt.Registry) error {

	if err := validate.Required("dependencies", "body", m.Dependencies); err != nil {
		return err
	}

	iDependenciesSize := int64(len(m.Dependencies))

	if err := validate.MinItems("dependencies", "body", iDependenciesSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.Dependencies); i++ {
		if swag.IsZero(m.Dependencies[i]) { // not required
			continue
		}

		if m.Dependencies[i] != nil {
			if err := m.Dependencies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependencies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build","runtime","test"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTypePropEnum = append(v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTypePropEnum, v)
	}
}

const (

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeBuild captures enum value "build"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeBuild string = "build"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeRuntime captures enum value "runtime"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeRuntime string = "runtime"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTest captures enum value "test"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTest string = "test"
)

// prop value enum
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0 Dependency
//
// A single dependency for an ingredient version revision
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0
type V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0 struct {

	// The features that must already be present in the recipe for this requirement to apply. For example, can be used to create requirements that only apply on specific operating systems.
	Conditions []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0 `json:"conditions"`

	// The name of the feature this ingredient version is dependent on
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the feature depended on is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Whatever text or data structure we parsed to generate this dependency
	OriginalRequirement string `json:"original_requirement,omitempty"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0 v1 build request recipe resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 conditions items0
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`

	// Whatever text or data structure we parsed to generate this condition
	OriginalCondition string `json:"original_condition,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		Namespace *string `json:"namespace"`

		Requirements []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.Namespace = dataAO0.Namespace

	m.Requirements = dataAO0.Requirements

	// AO1
	var dataAO1 struct {
		OriginalCondition string `json:"original_condition,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.OriginalCondition = dataAO1.OriginalCondition

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		Namespace *string `json:"namespace"`

		Requirements []*V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.Namespace = m.Namespace

	dataAO0.Requirements = m.Requirements

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		OriginalCondition string `json:"original_condition,omitempty"`
	}

	dataAO1.OriginalCondition = m.OriginalCondition

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 conditions items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 v1 build request recipe resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 conditions items0 requirements items0
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 conditions items0 requirements items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0 v1 build request recipe resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 requirements items0
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 requirements items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum = append(v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorEq string = "eq"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGt string = "gt"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGte string = "gte"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLt string = "lt"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLte string = "lte"

	// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0
type V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe resolved ingredients items0 ingredient version all of3 provided features items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0 Patch
//
// A diff of changes that can be applied to an ingredient's source code. This model contains all patch properties and is returned from read requests
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0
type V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0 struct {

	// creation timestamp
	// Required: true
	// Format: date-time
	CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

	// links
	// Required: true
	Links *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links `json:"links"`

	// patch id
	// Required: true
	// Format: uuid
	PatchID *strfmt.UUID `json:"patch_id"`

	// The features that must already be present in the recipe for this patch to be used. For example, can be used to create patches that only work on specific operating systems.
	Conditions []*V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0 `json:"conditions"`

	// The patch itself
	// Required: true
	Content *string `json:"content"`

	// A concise summary of what this patch can be used for
	// Required: true
	Description *string `json:"description"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links `json:"links"`

		PatchID *strfmt.UUID `json:"patch_id"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CreationTimestamp = dataAO0.CreationTimestamp

	m.Links = dataAO0.Links

	m.PatchID = dataAO0.PatchID

	// AO1
	var dataAO1 struct {
		Conditions []*V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0 `json:"conditions,omitempty"`

		Content *string `json:"content"`

		Description *string `json:"description"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Conditions = dataAO1.Conditions

	m.Content = dataAO1.Content

	m.Description = dataAO1.Description

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links `json:"links"`

		PatchID *strfmt.UUID `json:"patch_id"`
	}

	dataAO0.CreationTimestamp = m.CreationTimestamp

	dataAO0.Links = m.Links

	dataAO0.PatchID = m.PatchID

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		Conditions []*V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0 `json:"conditions,omitempty"`

		Content *string `json:"content"`

		Description *string `json:"description"`
	}

	dataAO1.Conditions = m.Conditions

	dataAO1.Content = m.Content

	dataAO1.Description = m.Description

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build request recipe resolved ingredients items0 patches items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePatchID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) validateCreationTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("creation_timestamp", "body", m.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("creation_timestamp", "body", "date-time", m.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) validatePatchID(formats strfmt.Registry) error {

	if err := validate.Required("patch_id", "body", m.PatchID); err != nil {
		return err
	}

	if err := validate.FormatOf("patch_id", "body", "uuid", m.PatchID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("content", "body", m.Content); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links Self Link
//
// A self link
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links
type V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 patches items0 a o0 links
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 patches items0 conditions items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0 v1 build request recipe resolved ingredients items0 patches items0 conditions items0 requirements items0
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 patches items0 conditions items0 requirements items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0 Requirement Sub Schema
//
// An order requirement is a single package name and version specifier requested in an order.
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0 struct {

	// The name of the required feature, If no ingredient ID is specified, the default provider of this feature will be chosen.
	// Required: true
	Feature *string `json:"feature"`

	// The ID of the ingredient version that should be used to fulfill this requirement. Can be used to override the default choice of provider for the specified feature. Must be an ingredient version that actually provides the specified feature.
	// Format: uuid
	IngredientVersionID strfmt.UUID `json:"ingredient_version_id,omitempty"`

	// The namespace for the required feature. For now, this can be empty as it is only used to request pre-platform installer ingredients.
	// Required: true
	Namespace *string `json:"namespace"`

	// The requirements for the acceptable versions of this feature. This can be omitted, in which case any version is acceptable.
	// Min Items: 1
	VersionRequirements []*V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0 `json:"version_requirements"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 resolved requirements items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersionRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0) validateIngredientVersionID(formats strfmt.Registry) error {

	if swag.IsZero(m.IngredientVersionID) { // not required
		return nil
	}

	if err := validate.FormatOf("ingredient_version_id", "body", "uuid", m.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0) validateVersionRequirements(formats strfmt.Registry) error {

	if swag.IsZero(m.VersionRequirements) { // not required
		return nil
	}

	iVersionRequirementsSize := int64(len(m.VersionRequirements))

	if err := validate.MinItems("version_requirements", "body", iVersionRequirementsSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.VersionRequirements); i++ {
		if swag.IsZero(m.VersionRequirements[i]) { // not required
			continue
		}

		if m.VersionRequirements[i] != nil {
			if err := m.VersionRequirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("version_requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0 Version Requirement Sub Schema
//
// The version constraint for a feature
// swagger:model V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0
type V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0 struct {

	// The operator used to compare the version against a given provided feature to determine if it meets this requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// The required version in its original form
	// Required: true
	// Min Length: 1
	Version *string `json:"version"`
}

// Validate validates this v1 build request recipe resolved ingredients items0 resolved requirements items0 version requirements items0
func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0TypeComparatorPropEnum = append(v1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorEq captures enum value "eq"
	V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorEq string = "eq"

	// V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorGt captures enum value "gt"
	V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorGt string = "gt"

	// V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorGte captures enum value "gte"
	V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorGte string = "gte"

	// V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorLt captures enum value "lt"
	V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorLt string = "lt"

	// V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorLte captures enum value "lte"
	V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorLte string = "lte"

	// V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorNe captures enum value "ne"
	V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildRequestRecipeResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Requester Requester
//
// Identifying information about who is placing the build request
// swagger:model Requester
type Requester struct {

	// The UUID of the platform organization that owns the project being built
	// Required: true
	// Format: uuid
	OrganizationID *strfmt.UUID `json:"organization_id"`

	// The UUID of the platform project being built by this build request
	// Required: true
	// Format: uuid
	ProjectID *strfmt.UUID `json:"project_id"`

	// The UUID of the platform user who initiated the build request
	// Required: true
	// Format: uuid
	UserID *strfmt.UUID `json:"user_id"`
}

// Validate validates this requester
func (m *Requester) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOrganizationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Requester) validateOrganizationID(formats strfmt.Registry) error {

	if err := validate.Required("requester"+"."+"organization_id", "body", m.OrganizationID); err != nil {
		return err
	}

	if err := validate.FormatOf("requester"+"."+"organization_id", "body", "uuid", m.OrganizationID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Requester) validateProjectID(formats strfmt.Registry) error {

	if err := validate.Required("requester"+"."+"project_id", "body", m.ProjectID); err != nil {
		return err
	}

	if err := validate.FormatOf("requester"+"."+"project_id", "body", "uuid", m.ProjectID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Requester) validateUserID(formats strfmt.Registry) error {

	if err := validate.Required("requester"+"."+"user_id", "body", m.UserID); err != nil {
		return err
	}

	if err := validate.FormatOf("requester"+"."+"user_id", "body", "uuid", m.UserID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Requester) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Requester) UnmarshalBinary(b []byte) error {
	var res Requester
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
