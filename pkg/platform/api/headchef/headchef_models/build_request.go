// Code generated by go-swagger; DO NOT EDIT.

package headchef_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BuildRequest Build Request
//
// A build request which is submitted to the Head Chef REST API.
// swagger:model buildRequest
type BuildRequest struct {

	// A list of additional command-line parameters to pass to setup-builds.pl. NOTE: this is a temporary feature to expose some camel features before build options are implemented.
	// Unique: true
	CamelFlags []string `json:"camel_flags"`

	// format
	// Required: true
	// Enum: [7zip dmg msi raw tarball zip]
	Format *string `json:"format"`

	// recipe
	// Required: true
	Recipe *BuildRequestRecipe `json:"recipe"`

	// requester
	Requester *Requester `json:"requester,omitempty"`
}

// Validate validates this build request
func (m *BuildRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCamelFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipe(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequester(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var buildRequestCamelFlagsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["--dynamic-core","--python-debug","--tcl-debug","--tcl-disable-threads"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestCamelFlagsItemsEnum = append(buildRequestCamelFlagsItemsEnum, v)
	}
}

func (m *BuildRequest) validateCamelFlagsItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestCamelFlagsItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequest) validateCamelFlags(formats strfmt.Registry) error {

	if swag.IsZero(m.CamelFlags) { // not required
		return nil
	}

	if err := validate.UniqueItems("camel_flags", "body", m.CamelFlags); err != nil {
		return err
	}

	for i := 0; i < len(m.CamelFlags); i++ {

		// value enum
		if err := m.validateCamelFlagsItemsEnum("camel_flags"+"."+strconv.Itoa(i), "body", m.CamelFlags[i]); err != nil {
			return err
		}

	}

	return nil
}

var buildRequestTypeFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["7zip","dmg","msi","raw","tarball","zip"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestTypeFormatPropEnum = append(buildRequestTypeFormatPropEnum, v)
	}
}

const (

	// BuildRequestFormatNr7zip captures enum value "7zip"
	BuildRequestFormatNr7zip string = "7zip"

	// BuildRequestFormatDmg captures enum value "dmg"
	BuildRequestFormatDmg string = "dmg"

	// BuildRequestFormatMsi captures enum value "msi"
	BuildRequestFormatMsi string = "msi"

	// BuildRequestFormatRaw captures enum value "raw"
	BuildRequestFormatRaw string = "raw"

	// BuildRequestFormatTarball captures enum value "tarball"
	BuildRequestFormatTarball string = "tarball"

	// BuildRequestFormatZip captures enum value "zip"
	BuildRequestFormatZip string = "zip"
)

// prop value enum
func (m *BuildRequest) validateFormatEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestTypeFormatPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequest) validateFormat(formats strfmt.Registry) error {

	if err := validate.Required("format", "body", m.Format); err != nil {
		return err
	}

	// value enum
	if err := m.validateFormatEnum("format", "body", *m.Format); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequest) validateRecipe(formats strfmt.Registry) error {

	if err := validate.Required("recipe", "body", m.Recipe); err != nil {
		return err
	}

	if m.Recipe != nil {
		if err := m.Recipe.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipe")
			}
			return err
		}
	}

	return nil
}

func (m *BuildRequest) validateRequester(formats strfmt.Registry) error {

	if swag.IsZero(m.Requester) { // not required
		return nil
	}

	if m.Requester != nil {
		if err := m.Requester.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("requester")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequest) UnmarshalBinary(b []byte) error {
	var res BuildRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipe Recipe
//
// A recipe contains the exact ingredient versions, including dependencies, needed to build a project for a single platform.
// swagger:model BuildRequestRecipe
type BuildRequestRecipe struct {

	// List of build options which are selected for this recipe.
	BuildOptions []*BuildRequestRecipeBuildOptionsItems0 `json:"build_options"`

	// The name of the image that will be used to build this recipe.
	Image string `json:"image,omitempty"`

	// The type of image that will be used to build this recipe.
	// Enum: [Docker WindowsInstance]
	ImageType string `json:"image_type,omitempty"`

	// Platform ID for the recipe.
	// Required: true
	// Format: uuid
	PlatformID *strfmt.UUID `json:"platform_id"`

	// Recipe UUID
	// Required: true
	// Format: uuid
	RecipeID *strfmt.UUID `json:"recipe_id"`

	// Resolved list of requirements. For each requirement in the original order there will be a corresponding ingredient version.
	// Required: true
	ResolvedRequirements []*BuildRequestRecipeResolvedRequirementsItems0 `json:"resolved_requirements"`
}

// Validate validates this build request recipe
func (m *BuildRequestRecipe) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImageType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolvedRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildRequestRecipe) validateBuildOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.BuildOptions); i++ {
		if swag.IsZero(m.BuildOptions[i]) { // not required
			continue
		}

		if m.BuildOptions[i] != nil {
			if err := m.BuildOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recipe" + "." + "build_options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var buildRequestRecipeTypeImageTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Docker","WindowsInstance"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestRecipeTypeImageTypePropEnum = append(buildRequestRecipeTypeImageTypePropEnum, v)
	}
}

const (

	// BuildRequestRecipeImageTypeDocker captures enum value "Docker"
	BuildRequestRecipeImageTypeDocker string = "Docker"

	// BuildRequestRecipeImageTypeWindowsInstance captures enum value "WindowsInstance"
	BuildRequestRecipeImageTypeWindowsInstance string = "WindowsInstance"
)

// prop value enum
func (m *BuildRequestRecipe) validateImageTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestRecipeTypeImageTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequestRecipe) validateImageType(formats strfmt.Registry) error {

	if swag.IsZero(m.ImageType) { // not required
		return nil
	}

	// value enum
	if err := m.validateImageTypeEnum("recipe"+"."+"image_type", "body", m.ImageType); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipe) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"platform_id", "body", "uuid", m.PlatformID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipe) validateRecipeID(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"recipe_id", "body", m.RecipeID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe"+"."+"recipe_id", "body", "uuid", m.RecipeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipe) validateResolvedRequirements(formats strfmt.Registry) error {

	if err := validate.Required("recipe"+"."+"resolved_requirements", "body", m.ResolvedRequirements); err != nil {
		return err
	}

	for i := 0; i < len(m.ResolvedRequirements); i++ {
		if swag.IsZero(m.ResolvedRequirements[i]) { // not required
			continue
		}

		if m.ResolvedRequirements[i] != nil {
			if err := m.ResolvedRequirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recipe" + "." + "resolved_requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipe) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipe) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipe
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeBuildOptionsItems0 Build Option
//
// A build option is a setting for all ingredients in a recipe.
// swagger:model BuildRequestRecipeBuildOptionsItems0
type BuildRequestRecipeBuildOptionsItems0 struct {

	// Build option name
	// Required: true
	// Enum: [debug static threaded]
	Option *string `json:"option"`
}

// Validate validates this build request recipe build options items0
func (m *BuildRequestRecipeBuildOptionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOption(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var buildRequestRecipeBuildOptionsItems0TypeOptionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["debug","static","threaded"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestRecipeBuildOptionsItems0TypeOptionPropEnum = append(buildRequestRecipeBuildOptionsItems0TypeOptionPropEnum, v)
	}
}

const (

	// BuildRequestRecipeBuildOptionsItems0OptionDebug captures enum value "debug"
	BuildRequestRecipeBuildOptionsItems0OptionDebug string = "debug"

	// BuildRequestRecipeBuildOptionsItems0OptionStatic captures enum value "static"
	BuildRequestRecipeBuildOptionsItems0OptionStatic string = "static"

	// BuildRequestRecipeBuildOptionsItems0OptionThreaded captures enum value "threaded"
	BuildRequestRecipeBuildOptionsItems0OptionThreaded string = "threaded"
)

// prop value enum
func (m *BuildRequestRecipeBuildOptionsItems0) validateOptionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestRecipeBuildOptionsItems0TypeOptionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequestRecipeBuildOptionsItems0) validateOption(formats strfmt.Registry) error {

	if err := validate.Required("option", "body", m.Option); err != nil {
		return err
	}

	// value enum
	if err := m.validateOptionEnum("option", "body", *m.Option); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeBuildOptionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeBuildOptionsItems0) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeBuildOptionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0 A resolved requirement for a recipe
// swagger:model BuildRequestRecipeResolvedRequirementsItems0
type BuildRequestRecipeResolvedRequirementsItems0 struct {

	// Alternative ingredient versions which can also satisfy the order's requirement. Each entry in the array is an ingredient version which could satisfy this requirements.
	Alternatives []strfmt.UUID `json:"alternatives"`

	// Build flags that will be applied to this ingredient version in the recipe.
	BuildFlags []*BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0 `json:"build_flags"`

	// For each package required by a requirement, whether this ingredient version is the default provider of that package. If this ingredient version is only included as a dependency, this field will be empty.
	DefaultPackageProviders map[string]bool `json:"default_package_providers,omitempty"`

	// The dependencies in the recipe for this ingredient version. Each item contains an ingredient version ID which will map to an ingredient version in this recipe..
	Dependencies []*BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0 `json:"dependencies"`

	// ingredient
	// Required: true
	Ingredient *BuildRequestRecipeResolvedRequirementsItems0Ingredient `json:"ingredient"`

	// ingredient version
	// Required: true
	IngredientVersion *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion `json:"ingredient_version"`

	// The original requirement(s) in the order that has been resolved to this ingredient and version. This list will be empty if an ingredient version is only being included as a dependency of something in the order.
	Requirements []*BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this build request recipe resolved requirements items0
func (m *BuildRequestRecipeResolvedRequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlternatives(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuildFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredient(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0) validateAlternatives(formats strfmt.Registry) error {

	if swag.IsZero(m.Alternatives) { // not required
		return nil
	}

	for i := 0; i < len(m.Alternatives); i++ {

		if err := validate.FormatOf("alternatives"+"."+strconv.Itoa(i), "body", "uuid", m.Alternatives[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0) validateBuildFlags(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildFlags) { // not required
		return nil
	}

	for i := 0; i < len(m.BuildFlags); i++ {
		if swag.IsZero(m.BuildFlags[i]) { // not required
			continue
		}

		if m.BuildFlags[i] != nil {
			if err := m.BuildFlags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("build_flags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0) validateDependencies(formats strfmt.Registry) error {

	if swag.IsZero(m.Dependencies) { // not required
		return nil
	}

	for i := 0; i < len(m.Dependencies); i++ {
		if swag.IsZero(m.Dependencies[i]) { // not required
			continue
		}

		if m.Dependencies[i] != nil {
			if err := m.Dependencies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependencies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0) validateIngredient(formats strfmt.Registry) error {

	if err := validate.Required("ingredient", "body", m.Ingredient); err != nil {
		return err
	}

	if m.Ingredient != nil {
		if err := m.Ingredient.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingredient")
			}
			return err
		}
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0) validateIngredientVersion(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version", "body", m.IngredientVersion); err != nil {
		return err
	}

	if m.IngredientVersion != nil {
		if err := m.IngredientVersion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingredient_version")
			}
			return err
		}
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0) validateRequirements(formats strfmt.Registry) error {

	if swag.IsZero(m.Requirements) { // not required
		return nil
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0 build request recipe resolved requirements items0 build flags items0
// swagger:model BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0
type BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0 struct {

	// Some flags may add dependencies to a build depending on their value. This generator defines how that is done.
	DependencyGenerator []*BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 `json:"dependency_generator"`

	// A description of what this build flag does
	// Required: true
	Description *string `json:"description"`

	// Allowed values for enum-type flags.
	EnumValues []string `json:"enum_values"`

	// The actual flag.
	// Required: true
	Flag *string `json:"flag"`

	// The mechanism for setting this flag.
	// Required: true
	// Enum: [configure environment make]
	FlagType *string `json:"flag_type"`

	// inheritance strategy
	InheritanceStrategy *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy `json:"inheritance_strategy,omitempty"`

	// Can this flag be specified more than once? This should never be true for boolean flags.
	// Required: true
	IsRepeatable *bool `json:"is_repeatable"`

	// The type of the build flag's value.
	// Required: true
	// Enum: [boolean enum integer string]
	ValueType *string `json:"value_type"`

	// The value chosen for this build flag.
	Value interface{} `json:"value,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		DependencyGenerator []*BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 `json:"dependency_generator,omitempty"`

		Description *string `json:"description"`

		EnumValues []string `json:"enum_values,omitempty"`

		Flag *string `json:"flag"`

		FlagType *string `json:"flag_type"`

		InheritanceStrategy *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy `json:"inheritance_strategy,omitempty"`

		IsRepeatable *bool `json:"is_repeatable"`

		ValueType *string `json:"value_type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.DependencyGenerator = dataAO0.DependencyGenerator

	m.Description = dataAO0.Description

	m.EnumValues = dataAO0.EnumValues

	m.Flag = dataAO0.Flag

	m.FlagType = dataAO0.FlagType

	m.InheritanceStrategy = dataAO0.InheritanceStrategy

	m.IsRepeatable = dataAO0.IsRepeatable

	m.ValueType = dataAO0.ValueType

	// AO1
	var dataAO1 struct {
		Value interface{} `json:"value,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Value = dataAO1.Value

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		DependencyGenerator []*BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 `json:"dependency_generator,omitempty"`

		Description *string `json:"description"`

		EnumValues []string `json:"enum_values,omitempty"`

		Flag *string `json:"flag"`

		FlagType *string `json:"flag_type"`

		InheritanceStrategy *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy `json:"inheritance_strategy,omitempty"`

		IsRepeatable *bool `json:"is_repeatable"`

		ValueType *string `json:"value_type"`
	}

	dataAO0.DependencyGenerator = m.DependencyGenerator

	dataAO0.Description = m.Description

	dataAO0.EnumValues = m.EnumValues

	dataAO0.Flag = m.Flag

	dataAO0.FlagType = m.FlagType

	dataAO0.InheritanceStrategy = m.InheritanceStrategy

	dataAO0.IsRepeatable = m.IsRepeatable

	dataAO0.ValueType = m.ValueType

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		Value interface{} `json:"value,omitempty"`
	}

	dataAO1.Value = m.Value

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this build request recipe resolved requirements items0 build flags items0
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencyGenerator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlagType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInheritanceStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsRepeatable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) validateDependencyGenerator(formats strfmt.Registry) error {

	if swag.IsZero(m.DependencyGenerator) { // not required
		return nil
	}

	for i := 0; i < len(m.DependencyGenerator); i++ {
		if swag.IsZero(m.DependencyGenerator[i]) { // not required
			continue
		}

		if m.DependencyGenerator[i] != nil {
			if err := m.DependencyGenerator[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependency_generator" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) validateFlag(formats strfmt.Registry) error {

	if err := validate.Required("flag", "body", m.Flag); err != nil {
		return err
	}

	return nil
}

var buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0TypeFlagTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["configure","environment","make"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0TypeFlagTypePropEnum = append(buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0TypeFlagTypePropEnum, v)
	}
}

// property enum
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) validateFlagTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0TypeFlagTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) validateFlagType(formats strfmt.Registry) error {

	if err := validate.Required("flag_type", "body", m.FlagType); err != nil {
		return err
	}

	// value enum
	if err := m.validateFlagTypeEnum("flag_type", "body", *m.FlagType); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) validateInheritanceStrategy(formats strfmt.Registry) error {

	if swag.IsZero(m.InheritanceStrategy) { // not required
		return nil
	}

	if m.InheritanceStrategy != nil {
		if err := m.InheritanceStrategy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inheritance_strategy")
			}
			return err
		}
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) validateIsRepeatable(formats strfmt.Registry) error {

	if err := validate.Required("is_repeatable", "body", m.IsRepeatable); err != nil {
		return err
	}

	return nil
}

var buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0TypeValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["boolean","enum","integer","string"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0TypeValueTypePropEnum = append(buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0TypeValueTypePropEnum, v)
	}
}

// property enum
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) validateValueTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0TypeValueTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) validateValueType(formats strfmt.Registry) error {

	if err := validate.Required("value_type", "body", m.ValueType); err != nil {
		return err
	}

	// value enum
	if err := m.validateValueTypeEnum("value_type", "body", *m.ValueType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy The strategy describes how this flag is inherited from other build ingredients. If this is not set then the flag is entirely independent.
// swagger:model BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy
type BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy struct {

	// The name of the dependency from which to get the flag value when the strategy is 'dependency'.
	DependencyName string `json:"dependency_name,omitempty"`

	// If the strategy is 'language_core' then it is derived by looking for a flag of the same name in the language core build flags. If the strategy is 'dependency' then it looks at the value of a dependency matching a certain name in the build. If this is omitted then it is set unconditionally based on the recipe's settings for this ingredient version
	// Required: true
	// Enum: [dependency language_core]
	Strategy *string `json:"strategy"`
}

// Validate validates this build request recipe resolved requirements items0 build flags items0 a o0 inheritance strategy
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStrategy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyTypeStrategyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["dependency","language_core"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyTypeStrategyPropEnum = append(buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyTypeStrategyPropEnum, v)
	}
}

const (

	// BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyStrategyDependency captures enum value "dependency"
	BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyStrategyDependency string = "dependency"

	// BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyStrategyLanguageCore captures enum value "language_core"
	BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyStrategyLanguageCore string = "language_core"
)

// prop value enum
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) validateStrategyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyTypeStrategyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) validateStrategy(formats strfmt.Registry) error {

	if err := validate.Required("inheritance_strategy"+"."+"strategy", "body", m.Strategy); err != nil {
		return err
	}

	// value enum
	if err := m.validateStrategyEnum("inheritance_strategy"+"."+"strategy", "body", *m.Strategy); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 build request recipe resolved requirements items0 build flags items0 dependency generator items0
// swagger:model BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0
type BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 struct {

	// When this is true the dependency is added.
	// Required: true
	Condition *string `json:"condition"`

	// DSL code to generate the dependency that is needed. This is expected to return a list of paired names and version specs.
	// Required: true
	Dependencies *string `json:"dependencies"`
}

// Validate validates this build request recipe resolved requirements items0 build flags items0 dependency generator items0
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) validateCondition(formats strfmt.Registry) error {

	if err := validate.Required("condition", "body", m.Condition); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) validateDependencies(formats strfmt.Registry) error {

	if err := validate.Required("dependencies", "body", m.Dependencies); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0 build request recipe resolved requirements items0 dependencies items0
// swagger:model BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0
type BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0 struct {

	// The type or types of dependencies on this ingredient version.
	// Required: true
	// Min Items: 1
	// Unique: true
	DependencyTypes []string `json:"dependency_types"`

	// ingredient version id
	// Required: true
	// Format: uuid
	IngredientVersionID *strfmt.UUID `json:"ingredient_version_id"`
}

// Validate validates this build request recipe resolved requirements items0 dependencies items0
func (m *BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencyTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var buildRequestRecipeResolvedRequirementsItems0DependenciesItems0DependencyTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build","runtime"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestRecipeResolvedRequirementsItems0DependenciesItems0DependencyTypesItemsEnum = append(buildRequestRecipeResolvedRequirementsItems0DependenciesItems0DependencyTypesItemsEnum, v)
	}
}

func (m *BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0) validateDependencyTypesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestRecipeResolvedRequirementsItems0DependenciesItems0DependencyTypesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0) validateDependencyTypes(formats strfmt.Registry) error {

	if err := validate.Required("dependency_types", "body", m.DependencyTypes); err != nil {
		return err
	}

	iDependencyTypesSize := int64(len(m.DependencyTypes))

	if err := validate.MinItems("dependency_types", "body", iDependencyTypesSize, 1); err != nil {
		return err
	}

	if err := validate.UniqueItems("dependency_types", "body", m.DependencyTypes); err != nil {
		return err
	}

	for i := 0; i < len(m.DependencyTypes); i++ {

		// value enum
		if err := m.validateDependencyTypesItemsEnum("dependency_types"+"."+strconv.Itoa(i), "body", m.DependencyTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0) validateIngredientVersionID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version_id", "body", m.IngredientVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version_id", "body", "uuid", m.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0DependenciesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0Ingredient Ingredient Core Properties Sub Schema
//
// The core properties of an ingredient. This is split out for sharing between multiple schemas.
// swagger:model BuildRequestRecipeResolvedRequirementsItems0Ingredient
type BuildRequestRecipeResolvedRequirementsItems0Ingredient struct {

	// description
	// Required: true
	Description *string `json:"description"`

	// ingredient id
	// Required: true
	// Format: uuid
	IngredientID *strfmt.UUID `json:"ingredient_id"`

	// name
	// Required: true
	Name *string `json:"name"`

	// The namespace is used to disambiguate ingredients across languages. For example, we could have multiple ingredients named "openssl" where one is a C library and the other is a Python library. For now, this is only used for the "pre-platform-installer" namespace.
	Namespace string `json:"namespace,omitempty"`
}

// Validate validates this build request recipe resolved requirements items0 ingredient
func (m *BuildRequestRecipeResolvedRequirementsItems0Ingredient) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0Ingredient) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0Ingredient) validateIngredientID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"ingredient_id", "body", m.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"ingredient_id", "body", "uuid", m.IngredientID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0Ingredient) validateName(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0Ingredient) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0Ingredient) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0Ingredient
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0IngredientVersion Ingredient Version Core Properties Sub Schema
//
// The core properties of an ingredient version. This is split out for sharing between multiple schemas.
// swagger:model BuildRequestRecipeResolvedRequirementsItems0IngredientVersion
type BuildRequestRecipeResolvedRequirementsItems0IngredientVersion struct {

	// One or more optional build flags that can be applied to this ingredient when it is built.
	BuildFlags []*BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0 `json:"build_flags"`

	// description
	// Required: true
	Description *string `json:"description"`

	// ingredient id
	// Required: true
	// Format: uuid
	IngredientID *strfmt.UUID `json:"ingredient_id"`

	// ingredient version id
	// Required: true
	// Format: uuid
	IngredientVersionID *strfmt.UUID `json:"ingredient_version_id"`

	// A release is not stable if it is an alpha, beta, developer test release, etc.
	// Required: true
	IsStableRelease *bool `json:"is_stable_release"`

	// The features provided by this ingredient version.
	Provides map[string]BuildRequestRecipeResolvedRequirementsItems0IngredientVersionProvidesAnon `json:"provides,omitempty"`

	// The release date for this version of the ingredient.
	// Required: true
	// Format: date-time
	ReleaseDate *strfmt.DateTime `json:"release_date"`

	// An internal version that starts at 1 and is incremented if any change is made to how this ingredient version is built.
	// Required: true
	// Minimum: 1
	Revision *int32 `json:"revision"`

	// A link to this ingredient's source code on the public Internet.
	// Required: true
	// Format: uri
	SourceURI *strfmt.URI `json:"source_uri"`

	// version
	// Required: true
	Version *string `json:"version"`
}

// Validate validates this build request recipe resolved requirements items0 ingredient version
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsStableRelease(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvides(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReleaseDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateBuildFlags(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildFlags) { // not required
		return nil
	}

	for i := 0; i < len(m.BuildFlags); i++ {
		if swag.IsZero(m.BuildFlags[i]) { // not required
			continue
		}

		if m.BuildFlags[i] != nil {
			if err := m.BuildFlags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ingredient_version" + "." + "build_flags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateIngredientID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"ingredient_id", "body", m.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"ingredient_id", "body", "uuid", m.IngredientID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateIngredientVersionID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"ingredient_version_id", "body", m.IngredientVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"ingredient_version_id", "body", "uuid", m.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateIsStableRelease(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"is_stable_release", "body", m.IsStableRelease); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateProvides(formats strfmt.Registry) error {

	if swag.IsZero(m.Provides) { // not required
		return nil
	}

	for k := range m.Provides {

		if swag.IsZero(m.Provides[k]) { // not required
			continue
		}
		if val, ok := m.Provides[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateReleaseDate(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"release_date", "body", m.ReleaseDate); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"release_date", "body", "date-time", m.ReleaseDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateRevision(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"revision", "body", m.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("ingredient_version"+"."+"revision", "body", int64(*m.Revision), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateSourceURI(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"source_uri", "body", m.SourceURI); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"source_uri", "body", "uri", m.SourceURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersion) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0IngredientVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0 Build Flag Sub Schema
//
// A build flag is a flag that can be passed when building an ingredient version.
// swagger:model BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0
type BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0 struct {

	// Some flags may add dependencies to a build depending on their value. This generator defines how that is done.
	DependencyGenerator []*BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0 `json:"dependency_generator"`

	// A description of what this build flag does
	// Required: true
	Description *string `json:"description"`

	// Allowed values for enum-type flags.
	EnumValues []string `json:"enum_values"`

	// The actual flag.
	// Required: true
	Flag *string `json:"flag"`

	// The mechanism for setting this flag.
	// Required: true
	// Enum: [configure environment make]
	FlagType *string `json:"flag_type"`

	// inheritance strategy
	InheritanceStrategy *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy `json:"inheritance_strategy,omitempty"`

	// Can this flag be specified more than once? This should never be true for boolean flags.
	// Required: true
	IsRepeatable *bool `json:"is_repeatable"`

	// The type of the build flag's value.
	// Required: true
	// Enum: [boolean enum integer string]
	ValueType *string `json:"value_type"`
}

// Validate validates this build request recipe resolved requirements items0 ingredient version build flags items0
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencyGenerator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlagType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInheritanceStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsRepeatable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateDependencyGenerator(formats strfmt.Registry) error {

	if swag.IsZero(m.DependencyGenerator) { // not required
		return nil
	}

	for i := 0; i < len(m.DependencyGenerator); i++ {
		if swag.IsZero(m.DependencyGenerator[i]) { // not required
			continue
		}

		if m.DependencyGenerator[i] != nil {
			if err := m.DependencyGenerator[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependency_generator" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateFlag(formats strfmt.Registry) error {

	if err := validate.Required("flag", "body", m.Flag); err != nil {
		return err
	}

	return nil
}

var buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeFlagTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["configure","environment","make"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeFlagTypePropEnum = append(buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeFlagTypePropEnum, v)
	}
}

const (

	// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeConfigure captures enum value "configure"
	BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeConfigure string = "configure"

	// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeEnvironment captures enum value "environment"
	BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeEnvironment string = "environment"

	// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeMake captures enum value "make"
	BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeMake string = "make"
)

// prop value enum
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateFlagTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeFlagTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateFlagType(formats strfmt.Registry) error {

	if err := validate.Required("flag_type", "body", m.FlagType); err != nil {
		return err
	}

	// value enum
	if err := m.validateFlagTypeEnum("flag_type", "body", *m.FlagType); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateInheritanceStrategy(formats strfmt.Registry) error {

	if swag.IsZero(m.InheritanceStrategy) { // not required
		return nil
	}

	if m.InheritanceStrategy != nil {
		if err := m.InheritanceStrategy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inheritance_strategy")
			}
			return err
		}
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateIsRepeatable(formats strfmt.Registry) error {

	if err := validate.Required("is_repeatable", "body", m.IsRepeatable); err != nil {
		return err
	}

	return nil
}

var buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["boolean","enum","integer","string"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeValueTypePropEnum = append(buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeValueTypePropEnum, v)
	}
}

const (

	// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeBoolean captures enum value "boolean"
	BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeBoolean string = "boolean"

	// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeEnum captures enum value "enum"
	BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeEnum string = "enum"

	// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeInteger captures enum value "integer"
	BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeInteger string = "integer"

	// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeString captures enum value "string"
	BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeString string = "string"
)

// prop value enum
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateValueTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeValueTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateValueType(formats strfmt.Registry) error {

	if err := validate.Required("value_type", "body", m.ValueType); err != nil {
		return err
	}

	// value enum
	if err := m.validateValueTypeEnum("value_type", "body", *m.ValueType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0 build request recipe resolved requirements items0 ingredient version build flags items0 dependency generator items0
// swagger:model BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0
type BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0 struct {

	// When this is true the dependency is added.
	// Required: true
	Condition *string `json:"condition"`

	// DSL code to generate the dependency that is needed. This is expected to return a list of paired names and version specs.
	// Required: true
	Dependencies *string `json:"dependencies"`
}

// Validate validates this build request recipe resolved requirements items0 ingredient version build flags items0 dependency generator items0
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) validateCondition(formats strfmt.Registry) error {

	if err := validate.Required("condition", "body", m.Condition); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) validateDependencies(formats strfmt.Registry) error {

	if err := validate.Required("dependencies", "body", m.Dependencies); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy The strategy describes how this flag is inherited from other build ingredients. If this is not set then the flag is entirely independent.
// swagger:model BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy
type BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy struct {

	// The name of the dependency from which to get the flag value when the strategy is 'dependency'.
	DependencyName string `json:"dependency_name,omitempty"`

	// If the strategy is 'language_core' then it is derived by looking for a flag of the same name in the language core build flags. If the strategy is 'dependency' then it looks at the value of a dependency matching a certain name in the build. If this is omitted then it is set unconditionally based on the recipe's settings for this ingredient version
	// Required: true
	// Enum: [dependency language_core]
	Strategy *string `json:"strategy"`
}

// Validate validates this build request recipe resolved requirements items0 ingredient version build flags items0 inheritance strategy
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStrategy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyTypeStrategyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["dependency","language_core"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyTypeStrategyPropEnum = append(buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyTypeStrategyPropEnum, v)
	}
}

const (

	// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyStrategyDependency captures enum value "dependency"
	BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyStrategyDependency string = "dependency"

	// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyStrategyLanguageCore captures enum value "language_core"
	BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyStrategyLanguageCore string = "language_core"
)

// prop value enum
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) validateStrategyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, buildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyTypeStrategyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) validateStrategy(formats strfmt.Registry) error {

	if err := validate.Required("inheritance_strategy"+"."+"strategy", "body", m.Strategy); err != nil {
		return err
	}

	// value enum
	if err := m.validateStrategyEnum("inheritance_strategy"+"."+"strategy", "body", *m.Strategy); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0IngredientVersionProvidesAnon Metadata about the provided features, keyed by feature name.
// swagger:model BuildRequestRecipeResolvedRequirementsItems0IngredientVersionProvidesAnon
type BuildRequestRecipeResolvedRequirementsItems0IngredientVersionProvidesAnon struct {

	// Whether this ingredient version is the default provider of this feature..
	IsDefault bool `json:"is_default,omitempty"`

	// The namespace to which the provided feature belongs.
	Namespace string `json:"namespace,omitempty"`

	// The version of this feature provided by the ingredient version.
	Version string `json:"version,omitempty"`
}

// Validate validates this build request recipe resolved requirements items0 ingredient version provides anon
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionProvidesAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionProvidesAnon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0IngredientVersionProvidesAnon) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0IngredientVersionProvidesAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0 Requirement Sub Schema
//
// A requirement is a single package name and version specifier.
// swagger:model BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0
type BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0 struct {

	// The ID of the ingredient that should be used to fulfill this requirement. Can be used to override the default choice of provider for the specified package. Must be an ingredient that actually provides the specified package.
	// Format: uuid
	IngredientID strfmt.UUID `json:"ingredient_id,omitempty"`

	// The namespace for the required package. For now, this can be empty as it is only used to request pre-platform installer ingredients.
	Namespace string `json:"namespace,omitempty"`

	// The name of the required package, If no ingredient ID is specified, the default provider of this package will be chosen.
	// Required: true
	PackageName *string `json:"package_name"`

	// The specifier for the acceptable versions of this package. This can be omitted, in which case any version is acceptable.
	VersionSpecifier string `json:"version_specifier,omitempty"`
}

// Validate validates this build request recipe resolved requirements items0 requirements items0
func (m *BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIngredientID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePackageName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0) validateIngredientID(formats strfmt.Registry) error {

	if swag.IsZero(m.IngredientID) { // not required
		return nil
	}

	if err := validate.FormatOf("ingredient_id", "body", "uuid", m.IngredientID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0) validatePackageName(formats strfmt.Registry) error {

	if err := validate.Required("package_name", "body", m.PackageName); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res BuildRequestRecipeResolvedRequirementsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
