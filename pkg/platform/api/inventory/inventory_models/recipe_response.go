// Code generated by go-swagger; DO NOT EDIT.

package inventory_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RecipeResponse Recipe Response
//
// The response to an order. It is a list of recipes satisfying the order.
// swagger:model recipeResponse
type RecipeResponse struct {

	// UID of the order for which this is a response.
	// Required: true
	// Format: uuid
	OrderID *strfmt.UUID `json:"order_id"`

	// List of resolved recipes by platform for a given order
	// Required: true
	Recipes []*RecipeResponseRecipesItems0 `json:"recipes"`
}

// Validate validates this recipe response
func (m *RecipeResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOrderID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponse) validateOrderID(formats strfmt.Registry) error {

	if err := validate.Required("order_id", "body", m.OrderID); err != nil {
		return err
	}

	if err := validate.FormatOf("order_id", "body", "uuid", m.OrderID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponse) validateRecipes(formats strfmt.Registry) error {

	if err := validate.Required("recipes", "body", m.Recipes); err != nil {
		return err
	}

	for i := 0; i < len(m.Recipes); i++ {
		if swag.IsZero(m.Recipes[i]) { // not required
			continue
		}

		if m.Recipes[i] != nil {
			if err := m.Recipes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recipes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponse) UnmarshalBinary(b []byte) error {
	var res RecipeResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0 Recipe
//
// A recipe contains the exact ingredient versions, including dependencies, needed to build a project for a single platform.
// swagger:model RecipeResponseRecipesItems0
type RecipeResponseRecipesItems0 struct {

	// List of build options which are selected for this recipe.
	BuildOptions []*RecipeResponseRecipesItems0BuildOptionsItems0 `json:"build_options"`

	// Platform ID for the recipe.
	// Required: true
	// Format: uuid
	PlatformID *strfmt.UUID `json:"platform_id"`

	// Recipe UUID
	// Required: true
	// Format: uuid
	RecipeID *strfmt.UUID `json:"recipe_id"`

	// Resolved list of requirements. For each requirement in the original order there will be a corresponding ingredient version.
	// Required: true
	ResolvedRequirements []*RecipeResponseRecipesItems0ResolvedRequirementsItems0 `json:"resolved_requirements"`
}

// Validate validates this recipe response recipes items0
func (m *RecipeResponseRecipesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolvedRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponseRecipesItems0) validateBuildOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.BuildOptions); i++ {
		if swag.IsZero(m.BuildOptions[i]) { // not required
			continue
		}

		if m.BuildOptions[i] != nil {
			if err := m.BuildOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("build_options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecipeResponseRecipesItems0) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform_id", "body", "uuid", m.PlatformID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0) validateRecipeID(formats strfmt.Registry) error {

	if err := validate.Required("recipe_id", "body", m.RecipeID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe_id", "body", "uuid", m.RecipeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0) validateResolvedRequirements(formats strfmt.Registry) error {

	if err := validate.Required("resolved_requirements", "body", m.ResolvedRequirements); err != nil {
		return err
	}

	for i := 0; i < len(m.ResolvedRequirements); i++ {
		if swag.IsZero(m.ResolvedRequirements[i]) { // not required
			continue
		}

		if m.ResolvedRequirements[i] != nil {
			if err := m.ResolvedRequirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resolved_requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0BuildOptionsItems0 Build Option
//
// A build option is a setting for all ingredients in a recipe.
// swagger:model RecipeResponseRecipesItems0BuildOptionsItems0
type RecipeResponseRecipesItems0BuildOptionsItems0 struct {

	// Build option name
	// Required: true
	// Enum: [debug static threaded]
	Option *string `json:"option"`
}

// Validate validates this recipe response recipes items0 build options items0
func (m *RecipeResponseRecipesItems0BuildOptionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOption(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var recipeResponseRecipesItems0BuildOptionsItems0TypeOptionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["debug","static","threaded"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recipeResponseRecipesItems0BuildOptionsItems0TypeOptionPropEnum = append(recipeResponseRecipesItems0BuildOptionsItems0TypeOptionPropEnum, v)
	}
}

const (

	// RecipeResponseRecipesItems0BuildOptionsItems0OptionDebug captures enum value "debug"
	RecipeResponseRecipesItems0BuildOptionsItems0OptionDebug string = "debug"

	// RecipeResponseRecipesItems0BuildOptionsItems0OptionStatic captures enum value "static"
	RecipeResponseRecipesItems0BuildOptionsItems0OptionStatic string = "static"

	// RecipeResponseRecipesItems0BuildOptionsItems0OptionThreaded captures enum value "threaded"
	RecipeResponseRecipesItems0BuildOptionsItems0OptionThreaded string = "threaded"
)

// prop value enum
func (m *RecipeResponseRecipesItems0BuildOptionsItems0) validateOptionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recipeResponseRecipesItems0BuildOptionsItems0TypeOptionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecipeResponseRecipesItems0BuildOptionsItems0) validateOption(formats strfmt.Registry) error {

	if err := validate.Required("option", "body", m.Option); err != nil {
		return err
	}

	// value enum
	if err := m.validateOptionEnum("option", "body", *m.Option); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0BuildOptionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0BuildOptionsItems0) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0BuildOptionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0 A resolved requirement for a recipe
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0
type RecipeResponseRecipesItems0ResolvedRequirementsItems0 struct {

	// Alternative ingredient versions which can also satisfy the order's requirement. Each entry in the array is an ingredient version which could satisfy this requirements.
	Alternatives []strfmt.UUID `json:"alternatives"`

	// Build flags that will be applied to this ingredient version in the recipe.
	BuildFlags []*RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0 `json:"build_flags"`

	// For each package required by a requirement, whether this ingredient version is the default provider of that package. If this ingredient version is only included as a dependency, this field will be empty.
	DefaultPackageProviders map[string]bool `json:"default_package_providers,omitempty"`

	// The dependencies in the recipe for this ingredient version. Each item contains an ingredient version ID which will map to an ingredient version in this recipe..
	Dependencies []*RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0 `json:"dependencies"`

	// ingredient
	// Required: true
	Ingredient *RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient `json:"ingredient"`

	// ingredient version
	// Required: true
	IngredientVersion *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion `json:"ingredient_version"`

	// The original requirement(s) in the order that has been resolved to this ingredient and version. This list will be empty if an ingredient version is only being included as a dependency of something in the order.
	Requirements []*RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlternatives(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuildFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredient(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0) validateAlternatives(formats strfmt.Registry) error {

	if swag.IsZero(m.Alternatives) { // not required
		return nil
	}

	for i := 0; i < len(m.Alternatives); i++ {

		if err := validate.FormatOf("alternatives"+"."+strconv.Itoa(i), "body", "uuid", m.Alternatives[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0) validateBuildFlags(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildFlags) { // not required
		return nil
	}

	for i := 0; i < len(m.BuildFlags); i++ {
		if swag.IsZero(m.BuildFlags[i]) { // not required
			continue
		}

		if m.BuildFlags[i] != nil {
			if err := m.BuildFlags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("build_flags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0) validateDependencies(formats strfmt.Registry) error {

	if swag.IsZero(m.Dependencies) { // not required
		return nil
	}

	for i := 0; i < len(m.Dependencies); i++ {
		if swag.IsZero(m.Dependencies[i]) { // not required
			continue
		}

		if m.Dependencies[i] != nil {
			if err := m.Dependencies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependencies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0) validateIngredient(formats strfmt.Registry) error {

	if err := validate.Required("ingredient", "body", m.Ingredient); err != nil {
		return err
	}

	if m.Ingredient != nil {
		if err := m.Ingredient.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingredient")
			}
			return err
		}
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0) validateIngredientVersion(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version", "body", m.IngredientVersion); err != nil {
		return err
	}

	if m.IngredientVersion != nil {
		if err := m.IngredientVersion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingredient_version")
			}
			return err
		}
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0) validateRequirements(formats strfmt.Registry) error {

	if swag.IsZero(m.Requirements) { // not required
		return nil
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0 recipe response recipes items0 resolved requirements items0 build flags items0
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0
type RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0 struct {

	// Some flags may add dependencies to a build depending on their value. This generator defines how that is done.
	DependencyGenerator []*RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 `json:"dependency_generator"`

	// A description of what this build flag does
	// Required: true
	Description *string `json:"description"`

	// Allowed values for enum-type flags.
	EnumValues []string `json:"enum_values"`

	// The actual flag.
	// Required: true
	Flag *string `json:"flag"`

	// The mechanism for setting this flag.
	// Required: true
	// Enum: [configure environment make]
	FlagType *string `json:"flag_type"`

	// inheritance strategy
	InheritanceStrategy *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy `json:"inheritance_strategy,omitempty"`

	// Can this flag be specified more than once? This should never be true for boolean flags.
	// Required: true
	IsRepeatable *bool `json:"is_repeatable"`

	// The type of the build flag's value.
	// Required: true
	// Enum: [boolean enum integer string]
	ValueType *string `json:"value_type"`

	// The value chosen for this build flag.
	Value interface{} `json:"value,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		DependencyGenerator []*RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 `json:"dependency_generator"`

		Description *string `json:"description"`

		EnumValues []string `json:"enum_values"`

		Flag *string `json:"flag"`

		FlagType *string `json:"flag_type"`

		InheritanceStrategy *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy `json:"inheritance_strategy,omitempty"`

		IsRepeatable *bool `json:"is_repeatable"`

		ValueType *string `json:"value_type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.DependencyGenerator = dataAO0.DependencyGenerator

	m.Description = dataAO0.Description

	m.EnumValues = dataAO0.EnumValues

	m.Flag = dataAO0.Flag

	m.FlagType = dataAO0.FlagType

	m.InheritanceStrategy = dataAO0.InheritanceStrategy

	m.IsRepeatable = dataAO0.IsRepeatable

	m.ValueType = dataAO0.ValueType

	// AO1
	var dataAO1 struct {
		Value interface{} `json:"value,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Value = dataAO1.Value

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		DependencyGenerator []*RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 `json:"dependency_generator"`

		Description *string `json:"description"`

		EnumValues []string `json:"enum_values"`

		Flag *string `json:"flag"`

		FlagType *string `json:"flag_type"`

		InheritanceStrategy *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy `json:"inheritance_strategy,omitempty"`

		IsRepeatable *bool `json:"is_repeatable"`

		ValueType *string `json:"value_type"`
	}

	dataAO0.DependencyGenerator = m.DependencyGenerator

	dataAO0.Description = m.Description

	dataAO0.EnumValues = m.EnumValues

	dataAO0.Flag = m.Flag

	dataAO0.FlagType = m.FlagType

	dataAO0.InheritanceStrategy = m.InheritanceStrategy

	dataAO0.IsRepeatable = m.IsRepeatable

	dataAO0.ValueType = m.ValueType

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		Value interface{} `json:"value,omitempty"`
	}

	dataAO1.Value = m.Value

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this recipe response recipes items0 resolved requirements items0 build flags items0
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencyGenerator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlagType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInheritanceStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsRepeatable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) validateDependencyGenerator(formats strfmt.Registry) error {

	if swag.IsZero(m.DependencyGenerator) { // not required
		return nil
	}

	for i := 0; i < len(m.DependencyGenerator); i++ {
		if swag.IsZero(m.DependencyGenerator[i]) { // not required
			continue
		}

		if m.DependencyGenerator[i] != nil {
			if err := m.DependencyGenerator[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependency_generator" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) validateFlag(formats strfmt.Registry) error {

	if err := validate.Required("flag", "body", m.Flag); err != nil {
		return err
	}

	return nil
}

var recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0TypeFlagTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["configure","environment","make"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0TypeFlagTypePropEnum = append(recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0TypeFlagTypePropEnum, v)
	}
}

// property enum
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) validateFlagTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0TypeFlagTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) validateFlagType(formats strfmt.Registry) error {

	if err := validate.Required("flag_type", "body", m.FlagType); err != nil {
		return err
	}

	// value enum
	if err := m.validateFlagTypeEnum("flag_type", "body", *m.FlagType); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) validateInheritanceStrategy(formats strfmt.Registry) error {

	if swag.IsZero(m.InheritanceStrategy) { // not required
		return nil
	}

	if m.InheritanceStrategy != nil {
		if err := m.InheritanceStrategy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inheritance_strategy")
			}
			return err
		}
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) validateIsRepeatable(formats strfmt.Registry) error {

	if err := validate.Required("is_repeatable", "body", m.IsRepeatable); err != nil {
		return err
	}

	return nil
}

var recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0TypeValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["boolean","enum","integer","string"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0TypeValueTypePropEnum = append(recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0TypeValueTypePropEnum, v)
	}
}

// property enum
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) validateValueTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0TypeValueTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) validateValueType(formats strfmt.Registry) error {

	if err := validate.Required("value_type", "body", m.ValueType); err != nil {
		return err
	}

	// value enum
	if err := m.validateValueTypeEnum("value_type", "body", *m.ValueType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy The strategy describes how this flag is inherited from other build ingredients. If this is not set then the flag is entirely independent.
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy
type RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy struct {

	// The name of the dependency from which to get the flag value when the strategy is 'dependency'.
	DependencyName string `json:"dependency_name,omitempty"`

	// If the strategy is 'language_core' then it is derived by looking for a flag of the same name in the language core build flags. If the strategy is 'dependency' then it looks at the value of a dependency matching a certain name in the build. If this is omitted then it is set unconditionally based on the recipe's settings for this ingredient version
	// Required: true
	// Enum: [dependency language_core]
	Strategy *string `json:"strategy"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 build flags items0 a o0 inheritance strategy
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStrategy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyTypeStrategyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["dependency","language_core"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyTypeStrategyPropEnum = append(recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyTypeStrategyPropEnum, v)
	}
}

const (

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyStrategyDependency captures enum value "dependency"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyStrategyDependency string = "dependency"

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyStrategyLanguageCore captures enum value "language_core"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyStrategyLanguageCore string = "language_core"
)

// prop value enum
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) validateStrategyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategyTypeStrategyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) validateStrategy(formats strfmt.Registry) error {

	if err := validate.Required("inheritance_strategy"+"."+"strategy", "body", m.Strategy); err != nil {
		return err
	}

	// value enum
	if err := m.validateStrategyEnum("inheritance_strategy"+"."+"strategy", "body", *m.Strategy); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0AO0InheritanceStrategy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 recipe response recipes items0 resolved requirements items0 build flags items0 dependency generator items0
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0
type RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0 struct {

	// When this is true the dependency is added.
	// Required: true
	Condition *string `json:"condition"`

	// DSL code to generate the dependency that is needed. This is expected to return a list of paired names and version specs.
	// Required: true
	Dependencies *string `json:"dependencies"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 build flags items0 dependency generator items0
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) validateCondition(formats strfmt.Registry) error {

	if err := validate.Required("condition", "body", m.Condition); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) validateDependencies(formats strfmt.Registry) error {

	if err := validate.Required("dependencies", "body", m.Dependencies); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0BuildFlagsItems0DependencyGeneratorItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0 recipe response recipes items0 resolved requirements items0 dependencies items0
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0
type RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0 struct {

	// The type or types of dependencies on this ingredient version.
	// Required: true
	// Min Items: 1
	// Unique: true
	DependencyTypes []string `json:"dependency_types"`

	// ingredient version id
	// Required: true
	// Format: uuid
	IngredientVersionID *strfmt.UUID `json:"ingredient_version_id"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 dependencies items0
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencyTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var recipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0DependencyTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build","runtime"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0DependencyTypesItemsEnum = append(recipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0DependencyTypesItemsEnum, v)
	}
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0) validateDependencyTypesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0DependencyTypesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0) validateDependencyTypes(formats strfmt.Registry) error {

	if err := validate.Required("dependency_types", "body", m.DependencyTypes); err != nil {
		return err
	}

	iDependencyTypesSize := int64(len(m.DependencyTypes))

	if err := validate.MinItems("dependency_types", "body", iDependencyTypesSize, 1); err != nil {
		return err
	}

	if err := validate.UniqueItems("dependency_types", "body", m.DependencyTypes); err != nil {
		return err
	}

	for i := 0; i < len(m.DependencyTypes); i++ {

		// value enum
		if err := m.validateDependencyTypesItemsEnum("dependency_types"+"."+strconv.Itoa(i), "body", m.DependencyTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0) validateIngredientVersionID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version_id", "body", m.IngredientVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version_id", "body", "uuid", m.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0DependenciesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient Ingredient Core Properties Sub Schema
//
// The core properties of an ingredient. This is split out for sharing between multiple schemas.
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient
type RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient struct {

	// description
	// Required: true
	Description *string `json:"description"`

	// ingredient id
	// Required: true
	// Format: uuid
	IngredientID *strfmt.UUID `json:"ingredient_id"`

	// name
	// Required: true
	Name *string `json:"name"`

	// namespace
	Namespace string `json:"namespace,omitempty"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 ingredient
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient) validateIngredientID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"ingredient_id", "body", m.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"ingredient_id", "body", "uuid", m.IngredientID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient) validateName(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0Ingredient
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion Ingredient Version Core Properties Sub Schema
//
// The core properties of an ingredient version. This is split out for sharing between multiple schemas.
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion
type RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion struct {

	// One or more optional build flags that can be applied to this ingredient when it is built.
	BuildFlags []*RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0 `json:"build_flags"`

	// description
	// Required: true
	Description *string `json:"description"`

	// ingredient id
	// Required: true
	// Format: uuid
	IngredientID *strfmt.UUID `json:"ingredient_id"`

	// ingredient version id
	// Required: true
	// Format: uuid
	IngredientVersionID *strfmt.UUID `json:"ingredient_version_id"`

	// A release is not stable if it is an alpha, beta, developer test release, etc.
	// Required: true
	IsStableRelease *bool `json:"is_stable_release"`

	// The packages provided by this ingredient version.
	Provides map[string]RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionProvidesAnon `json:"provides,omitempty"`

	// The release date for this version of the ingredient.
	// Required: true
	// Format: date-time
	ReleaseDate *strfmt.DateTime `json:"release_date"`

	// An internal version that starts at 1 and is incremented if any change is made to how this ingredient version is built.
	// Required: true
	// Minimum: 1
	Revision *int32 `json:"revision"`

	// A link to this ingredient's source code on the public Internet.
	// Required: true
	// Format: uri
	SourceURI *strfmt.URI `json:"source_uri"`

	// version
	// Required: true
	Version *string `json:"version"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 ingredient version
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsStableRelease(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvides(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReleaseDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateBuildFlags(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildFlags) { // not required
		return nil
	}

	for i := 0; i < len(m.BuildFlags); i++ {
		if swag.IsZero(m.BuildFlags[i]) { // not required
			continue
		}

		if m.BuildFlags[i] != nil {
			if err := m.BuildFlags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ingredient_version" + "." + "build_flags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateIngredientID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"ingredient_id", "body", m.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"ingredient_id", "body", "uuid", m.IngredientID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateIngredientVersionID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"ingredient_version_id", "body", m.IngredientVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"ingredient_version_id", "body", "uuid", m.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateIsStableRelease(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"is_stable_release", "body", m.IsStableRelease); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateProvides(formats strfmt.Registry) error {

	if swag.IsZero(m.Provides) { // not required
		return nil
	}

	for k := range m.Provides {

		if swag.IsZero(m.Provides[k]) { // not required
			continue
		}
		if val, ok := m.Provides[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateReleaseDate(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"release_date", "body", m.ReleaseDate); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"release_date", "body", "date-time", m.ReleaseDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateRevision(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"revision", "body", m.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("ingredient_version"+"."+"revision", "body", int64(*m.Revision), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateSourceURI(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"source_uri", "body", m.SourceURI); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"source_uri", "body", "uri", m.SourceURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0 Build Flag Sub Schema
//
// A build flag is a flag that can be passed when building an ingredient version.
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0
type RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0 struct {

	// Some flags may add dependencies to a build depending on their value. This generator defines how that is done.
	DependencyGenerator []*RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0 `json:"dependency_generator"`

	// A description of what this build flag does
	// Required: true
	Description *string `json:"description"`

	// Allowed values for enum-type flags.
	EnumValues []string `json:"enum_values"`

	// The actual flag.
	// Required: true
	Flag *string `json:"flag"`

	// The mechanism for setting this flag.
	// Required: true
	// Enum: [configure environment make]
	FlagType *string `json:"flag_type"`

	// inheritance strategy
	InheritanceStrategy *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy `json:"inheritance_strategy,omitempty"`

	// Can this flag be specified more than once? This should never be true for boolean flags.
	// Required: true
	IsRepeatable *bool `json:"is_repeatable"`

	// The type of the build flag's value.
	// Required: true
	// Enum: [boolean enum integer string]
	ValueType *string `json:"value_type"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 ingredient version build flags items0
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencyGenerator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlagType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInheritanceStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsRepeatable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateDependencyGenerator(formats strfmt.Registry) error {

	if swag.IsZero(m.DependencyGenerator) { // not required
		return nil
	}

	for i := 0; i < len(m.DependencyGenerator); i++ {
		if swag.IsZero(m.DependencyGenerator[i]) { // not required
			continue
		}

		if m.DependencyGenerator[i] != nil {
			if err := m.DependencyGenerator[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependency_generator" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateFlag(formats strfmt.Registry) error {

	if err := validate.Required("flag", "body", m.Flag); err != nil {
		return err
	}

	return nil
}

var recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeFlagTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["configure","environment","make"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeFlagTypePropEnum = append(recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeFlagTypePropEnum, v)
	}
}

const (

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeConfigure captures enum value "configure"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeConfigure string = "configure"

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeEnvironment captures enum value "environment"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeEnvironment string = "environment"

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeMake captures enum value "make"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0FlagTypeMake string = "make"
)

// prop value enum
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateFlagTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeFlagTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateFlagType(formats strfmt.Registry) error {

	if err := validate.Required("flag_type", "body", m.FlagType); err != nil {
		return err
	}

	// value enum
	if err := m.validateFlagTypeEnum("flag_type", "body", *m.FlagType); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateInheritanceStrategy(formats strfmt.Registry) error {

	if swag.IsZero(m.InheritanceStrategy) { // not required
		return nil
	}

	if m.InheritanceStrategy != nil {
		if err := m.InheritanceStrategy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inheritance_strategy")
			}
			return err
		}
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateIsRepeatable(formats strfmt.Registry) error {

	if err := validate.Required("is_repeatable", "body", m.IsRepeatable); err != nil {
		return err
	}

	return nil
}

var recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeValueTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["boolean","enum","integer","string"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeValueTypePropEnum = append(recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeValueTypePropEnum, v)
	}
}

const (

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeBoolean captures enum value "boolean"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeBoolean string = "boolean"

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeEnum captures enum value "enum"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeEnum string = "enum"

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeInteger captures enum value "integer"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeInteger string = "integer"

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeString captures enum value "string"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0ValueTypeString string = "string"
)

// prop value enum
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateValueTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0TypeValueTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) validateValueType(formats strfmt.Registry) error {

	if err := validate.Required("value_type", "body", m.ValueType); err != nil {
		return err
	}

	// value enum
	if err := m.validateValueTypeEnum("value_type", "body", *m.ValueType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0 recipe response recipes items0 resolved requirements items0 ingredient version build flags items0 dependency generator items0
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0
type RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0 struct {

	// When this is true the dependency is added.
	// Required: true
	Condition *string `json:"condition"`

	// DSL code to generate the dependency that is needed. This is expected to return a list of paired names and version specs.
	// Required: true
	Dependencies *string `json:"dependencies"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 ingredient version build flags items0 dependency generator items0
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) validateCondition(formats strfmt.Registry) error {

	if err := validate.Required("condition", "body", m.Condition); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) validateDependencies(formats strfmt.Registry) error {

	if err := validate.Required("dependencies", "body", m.Dependencies); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0DependencyGeneratorItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy The strategy describes how this flag is inherited from other build ingredients. If this is not set then the flag is entirely independent.
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy
type RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy struct {

	// The name of the dependency from which to get the flag value when the strategy is 'dependency'.
	DependencyName string `json:"dependency_name,omitempty"`

	// If the strategy is 'language_core' then it is derived by looking for a flag of the same name in the language core build flags. If the strategy is 'dependency' then it looks at the value of a dependency matching a certain name in the build. If this is omitted then it is set unconditionally based on the recipe's settings for this ingredient version
	// Required: true
	// Enum: [dependency language_core]
	Strategy *string `json:"strategy"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 ingredient version build flags items0 inheritance strategy
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStrategy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyTypeStrategyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["dependency","language_core"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyTypeStrategyPropEnum = append(recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyTypeStrategyPropEnum, v)
	}
}

const (

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyStrategyDependency captures enum value "dependency"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyStrategyDependency string = "dependency"

	// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyStrategyLanguageCore captures enum value "language_core"
	RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyStrategyLanguageCore string = "language_core"
)

// prop value enum
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) validateStrategyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, recipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategyTypeStrategyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) validateStrategy(formats strfmt.Registry) error {

	if err := validate.Required("inheritance_strategy"+"."+"strategy", "body", m.Strategy); err != nil {
		return err
	}

	// value enum
	if err := m.validateStrategyEnum("inheritance_strategy"+"."+"strategy", "body", *m.Strategy); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionBuildFlagsItems0InheritanceStrategy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionProvidesAnon Metadata about the provided packages, keyed by package name.
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionProvidesAnon
type RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionProvidesAnon struct {

	// Whether this ingredient version is the default provider of this package.
	IsDefault bool `json:"is_default,omitempty"`

	// The version of this package provided by the ingredient version.
	Version string `json:"version,omitempty"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 ingredient version provides anon
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionProvidesAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionProvidesAnon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionProvidesAnon) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0IngredientVersionProvidesAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0 Requirement Sub Schema
//
// A requirement is a single package name and version specifier.
// swagger:model RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0
type RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0 struct {

	// The ID of the ingredient that should be used to fulfill this requirement. Can be used to override the default choice of provider for the specified package. Must be an ingredient that actually provides the specified package.
	// Format: uuid
	IngredientID strfmt.UUID `json:"ingredient_id,omitempty"`

	// The namespace for the required package. For now, this can be empty as it is only used to request pre-platform installer ingredients.
	Namespace string `json:"namespace,omitempty"`

	// The name of the required package, If no ingredient ID is specified, the default provider of this package will be chosen.
	// Required: true
	PackageName *string `json:"package_name"`

	// The specifier for the acceptable versions of this package. This can be omitted, in which case any version is acceptable.
	VersionSpecifier string `json:"version_specifier,omitempty"`
}

// Validate validates this recipe response recipes items0 resolved requirements items0 requirements items0
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIngredientID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePackageName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0) validateIngredientID(formats strfmt.Registry) error {

	if swag.IsZero(m.IngredientID) { // not required
		return nil
	}

	if err := validate.FormatOf("ingredient_id", "body", "uuid", m.IngredientID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0) validatePackageName(formats strfmt.Registry) error {

	if err := validate.Required("package_name", "body", m.PackageName); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res RecipeResponseRecipesItems0ResolvedRequirementsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
