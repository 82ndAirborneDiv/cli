// Code generated by go-swagger; DO NOT EDIT.

package inventory_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1IngredientAndVersionPagedList Ingredient And Version Paged List
//
// A paginated list of ingredients and versions
// swagger:model v1IngredientAndVersionPagedList
type V1IngredientAndVersionPagedList struct {

	// A page of ingredients and versions
	// Required: true
	IngredientsAndVersions []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0 `json:"ingredients_and_versions"`

	// links
	// Required: true
	Links *V1IngredientAndVersionPagedListLinks `json:"links"`

	// paging
	// Required: true
	Paging *V1IngredientAndVersionPagedListPaging `json:"paging"`
}

// Validate validates this v1 ingredient and version paged list
func (m *V1IngredientAndVersionPagedList) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIngredientsAndVersions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaging(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedList) validateIngredientsAndVersions(formats strfmt.Registry) error {

	if err := validate.Required("ingredients_and_versions", "body", m.IngredientsAndVersions); err != nil {
		return err
	}

	for i := 0; i < len(m.IngredientsAndVersions); i++ {
		if swag.IsZero(m.IngredientsAndVersions[i]) { // not required
			continue
		}

		if m.IngredientsAndVersions[i] != nil {
			if err := m.IngredientsAndVersions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ingredients_and_versions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1IngredientAndVersionPagedList) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1IngredientAndVersionPagedList) validatePaging(formats strfmt.Registry) error {

	if err := validate.Required("paging", "body", m.Paging); err != nil {
		return err
	}

	if m.Paging != nil {
		if err := m.Paging.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paging")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedList) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedList) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedList
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0 Ingredient And Version
//
// An ingredient paired with one of its versions
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0 struct {

	// Ingredient
	//
	// A unique ingredient that can be used in a recipe. This model contains all ingredient properties and is returned from read requests.
	// Required: true
	Ingredient struct {

		// creation timestamp
		// Required: true
		// Format: date-time
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		// ingredient id
		// Required: true
		// Format: uuid
		IngredientID *strfmt.UUID `json:"ingredient_id"`

		// links
		// Required: true
		Links *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0IngredientAO0Links `json:"links"`

		// A concise summary of what this ingredient can be used for
		// Required: true
		Description *string `json:"description"`

		// The name of the ingredient (excluding any version information)
		// Required: true
		Name *string `json:"name"`

		// The UUID of the organization the ingredient belongs to, if it is private to a particular organization
		// Required: true
		// Format: uuid
		OrganizationID *strfmt.UUID `json:"organization_id"`

		// The primary namespace to which this ingredient belongs
		// Required: true
		PrimaryNamespace *string `json:"primary_namespace"`

		// URL of the website about this ingredient (if any)
		// Required: true
		// Format: uri
		Website *strfmt.URI `json:"website"`
	} `json:"ingredient"`

	// Ingredient Version
	//
	// The full ingredient version data model. Returned from all read requests.
	// Required: true
	Version struct {

		// creation timestamp
		// Required: true
		// Format: date-time
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		// ingredient id
		// Required: true
		// Format: uuid
		IngredientID *strfmt.UUID `json:"ingredient_id"`

		// ingredient version id
		// Required: true
		// Format: uuid
		IngredientVersionID *strfmt.UUID `json:"ingredient_version_id"`

		// links
		// Required: true
		Links struct {

			// The URI of this resource
			// Required: true
			// Format: uri
			Self *strfmt.URI `json:"self"`

			// The URI of the ingredient this is a version of
			// Required: true
			// Format: uri
			Ingredient *strfmt.URI `json:"ingredient"`
		} `json:"links"`

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`

		V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2

		V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3
	} `json:"version"`
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIngredient(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0) validateIngredient(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"creation_timestamp", "body", m.Ingredient.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"creation_timestamp", "body", "date-time", m.Ingredient.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"ingredient_id", "body", m.Ingredient.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"ingredient_id", "body", "uuid", m.Ingredient.IngredientID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"links", "body", m.Ingredient.Links); err != nil {
		return err
	}

	if m.Ingredient.Links != nil {
		if err := m.Ingredient.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingredient" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("ingredient"+"."+"description", "body", m.Ingredient.Description); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"name", "body", m.Ingredient.Name); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"organization_id", "body", m.Ingredient.OrganizationID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"organization_id", "body", "uuid", m.Ingredient.OrganizationID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"primary_namespace", "body", m.Ingredient.PrimaryNamespace); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"website", "body", m.Ingredient.Website); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"website", "body", "uri", m.Ingredient.Website.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version"+"."+"creation_timestamp", "body", m.Version.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("version"+"."+"creation_timestamp", "body", "date-time", m.Version.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("version"+"."+"ingredient_id", "body", m.Version.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("version"+"."+"ingredient_id", "body", "uuid", m.Version.IngredientID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("version"+"."+"ingredient_version_id", "body", m.Version.IngredientVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("version"+"."+"ingredient_version_id", "body", "uuid", m.Version.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("version"+"."+"links"+"."+"self", "body", m.Version.Links.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("version"+"."+"links"+"."+"self", "body", "uri", m.Version.Links.Self.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("version"+"."+"links"+"."+"ingredient", "body", m.Version.Links.Ingredient); err != nil {
		return err
	}

	if err := validate.FormatOf("version"+"."+"links"+"."+"ingredient", "body", "uri", m.Version.Links.Ingredient.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("version"+"."+"revision", "body", m.Version.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("version"+"."+"revision", "body", int64(*m.Version.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("version"+"."+"revision_timestamp", "body", m.Version.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("version"+"."+"revision_timestamp", "body", "date-time", m.Version.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0IngredientAO0Links Self Link
//
// A self link
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0IngredientAO0Links
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0IngredientAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0 ingredient a o0 links
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0IngredientAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0IngredientAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0IngredientAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0IngredientAO0Links) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0IngredientAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2 Ingredient Version Core
//
// The fields of an ingredient version that can be set when an ingredient version is created
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2 struct {

	// The text from the license or elsewhere that declares the copyright holder(s) and year(s)
	// Required: true
	CopyrightText *string `json:"copyright_text"`

	// The URL of a webpage where the documentation for this ingredient version is hosted, if available
	// Format: uri
	DocumentationURI strfmt.URI `json:"documentation_uri,omitempty"`

	// Tells if this ingredient version consists of only a binary without any source.
	IsBinaryOnly *bool `json:"is_binary_only,omitempty"`

	// An SPDX 2.1 license expression describing the exact licensing for this ingredient version
	// Required: true
	LicenseExpression *string `json:"license_expression"`

	// The date and time this ingredient version was first released
	// Required: true
	// Format: date-time
	ReleaseTimestamp *strfmt.DateTime `json:"release_timestamp"`

	// The URL from which we initially retrieved the source for this ingredient version.
	// Format: uri
	SourceURI *strfmt.URI `json:"source_uri,omitempty"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CopyrightText *string `json:"copyright_text"`

		DocumentationURI strfmt.URI `json:"documentation_uri,omitempty"`

		IsBinaryOnly *bool `json:"is_binary_only,omitempty"`

		LicenseExpression *string `json:"license_expression"`

		ReleaseTimestamp *strfmt.DateTime `json:"release_timestamp"`

		SourceURI *strfmt.URI `json:"source_uri,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CopyrightText = dataAO0.CopyrightText

	m.DocumentationURI = dataAO0.DocumentationURI

	m.IsBinaryOnly = dataAO0.IsBinaryOnly

	m.LicenseExpression = dataAO0.LicenseExpression

	m.ReleaseTimestamp = dataAO0.ReleaseTimestamp

	m.SourceURI = dataAO0.SourceURI

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		CopyrightText *string `json:"copyright_text"`

		DocumentationURI strfmt.URI `json:"documentation_uri,omitempty"`

		IsBinaryOnly *bool `json:"is_binary_only,omitempty"`

		LicenseExpression *string `json:"license_expression"`

		ReleaseTimestamp *strfmt.DateTime `json:"release_timestamp"`

		SourceURI *strfmt.URI `json:"source_uri,omitempty"`
	}

	dataAO0.CopyrightText = m.CopyrightText

	dataAO0.DocumentationURI = m.DocumentationURI

	dataAO0.IsBinaryOnly = m.IsBinaryOnly

	dataAO0.LicenseExpression = m.LicenseExpression

	dataAO0.ReleaseTimestamp = m.ReleaseTimestamp

	dataAO0.SourceURI = m.SourceURI

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0 version all of2
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCopyrightText(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocumentationURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicenseExpression(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReleaseTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) validateCopyrightText(formats strfmt.Registry) error {

	if err := validate.Required("copyright_text", "body", m.CopyrightText); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) validateDocumentationURI(formats strfmt.Registry) error {

	if swag.IsZero(m.DocumentationURI) { // not required
		return nil
	}

	if err := validate.FormatOf("documentation_uri", "body", "uri", m.DocumentationURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) validateLicenseExpression(formats strfmt.Registry) error {

	if err := validate.Required("license_expression", "body", m.LicenseExpression); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) validateReleaseTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("release_timestamp", "body", m.ReleaseTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("release_timestamp", "body", "date-time", m.ReleaseTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) validateSourceURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceURI) { // not required
		return nil
	}

	if err := validate.FormatOf("source_uri", "body", "uri", m.SourceURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf2
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3 Ingredient Version Revision Core
//
// The fields of an ingredient version that can be updated by creating a new revision
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3 struct {

	// Camel-specific metadata needed to build this ingredient version revision in camel, if there is any.
	CamelExtras interface{} `json:"camel_extras,omitempty"`

	// dependency sets
	DependencySets []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0 `json:"dependency_sets"`

	// Whether or not this is a stable release of the package
	IsStableRelease *bool `json:"is_stable_release,omitempty"`

	// S3 URL where the source distribution is stored for our platform
	// Format: uri
	PlatformSourceURI *strfmt.URI `json:"platform_source_uri,omitempty"`

	// A checksum of the source distribution. The actual type of the checksum (MD5, S3 Etag, etc.) is not specified. It's assumed that the system that populates and uses this data will know how to work with these checksums.
	SourceChecksum *string `json:"source_checksum,omitempty"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CamelExtras interface{} `json:"camel_extras,omitempty"`

		DependencySets []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0 `json:"dependency_sets,omitempty"`

		IsStableRelease *bool `json:"is_stable_release,omitempty"`

		PlatformSourceURI *strfmt.URI `json:"platform_source_uri,omitempty"`

		SourceChecksum *string `json:"source_checksum,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CamelExtras = dataAO0.CamelExtras

	m.DependencySets = dataAO0.DependencySets

	m.IsStableRelease = dataAO0.IsStableRelease

	m.PlatformSourceURI = dataAO0.PlatformSourceURI

	m.SourceChecksum = dataAO0.SourceChecksum

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		CamelExtras interface{} `json:"camel_extras,omitempty"`

		DependencySets []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0 `json:"dependency_sets,omitempty"`

		IsStableRelease *bool `json:"is_stable_release,omitempty"`

		PlatformSourceURI *strfmt.URI `json:"platform_source_uri,omitempty"`

		SourceChecksum *string `json:"source_checksum,omitempty"`
	}

	dataAO0.CamelExtras = m.CamelExtras

	dataAO0.DependencySets = m.DependencySets

	dataAO0.IsStableRelease = m.IsStableRelease

	dataAO0.PlatformSourceURI = m.PlatformSourceURI

	dataAO0.SourceChecksum = m.SourceChecksum

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0 version all of3
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencySets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformSourceURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3) validateDependencySets(formats strfmt.Registry) error {

	if swag.IsZero(m.DependencySets) { // not required
		return nil
	}

	for i := 0; i < len(m.DependencySets); i++ {
		if swag.IsZero(m.DependencySets[i]) { // not required
			continue
		}

		if m.DependencySets[i] != nil {
			if err := m.DependencySets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependency_sets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3) validatePlatformSourceURI(formats strfmt.Registry) error {

	if swag.IsZero(m.PlatformSourceURI) { // not required
		return nil
	}

	if err := validate.FormatOf("platform_source_uri", "body", "uri", m.PlatformSourceURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0 v1 ingredient and version paged list ingredients and versions items0 version all of3 dependency sets items0
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0 struct {

	// dependencies
	// Required: true
	// Min Items: 1
	Dependencies []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0 `json:"dependencies"`

	// A description of this set.
	Description string `json:"description,omitempty"`

	// Whatever text or metadata was parsed to create this set.
	OriginalRequirement string `json:"original_requirement,omitempty"`

	// Recipe
	//
	// The different types of dependencies supported by the platform.
	// Required: true
	// Enum: [build runtime test]
	Type *string `json:"type"`
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0 version all of3 dependency sets items0
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0) validateDependencies(formats strfmt.Registry) error {

	if err := validate.Required("dependencies", "body", m.Dependencies); err != nil {
		return err
	}

	iDependenciesSize := int64(len(m.Dependencies))

	if err := validate.MinItems("dependencies", "body", iDependenciesSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.Dependencies); i++ {
		if swag.IsZero(m.Dependencies[i]) { // not required
			continue
		}

		if m.Dependencies[i] != nil {
			if err := m.Dependencies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependencies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build","runtime","test"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeTypePropEnum = append(v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeTypePropEnum, v)
	}
}

const (

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeBuild captures enum value "build"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeBuild string = "build"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeRuntime captures enum value "runtime"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeRuntime string = "runtime"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeTest captures enum value "test"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeTest string = "test"
)

// prop value enum
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0TypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0 Dependency
//
// A single dependency for an ingredient version revision
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0 struct {

	// The features that must already be present in the recipe for this requirement to apply. For example, can be used to create requirements that only apply on specific operating systems.
	Conditions []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0 `json:"conditions"`

	// The name of the feature this ingredient version is dependent on
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the feature depended on is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Whatever text or data structure we parsed to generate this dependency
	OriginalRequirement string `json:"original_requirement,omitempty"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0 version all of3 dependency sets items0 dependencies items0
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0 v1 ingredient and version paged list ingredients and versions items0 version all of3 dependency sets items0 dependencies items0 conditions items0
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`

	// Whatever text or data structure we parsed to generate this condition
	OriginalCondition string `json:"original_condition,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		Namespace *string `json:"namespace"`

		Requirements []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.Namespace = dataAO0.Namespace

	m.Requirements = dataAO0.Requirements

	// AO1
	var dataAO1 struct {
		OriginalCondition string `json:"original_condition,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.OriginalCondition = dataAO1.OriginalCondition

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		Namespace *string `json:"namespace"`

		Requirements []*V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.Namespace = m.Namespace

	dataAO0.Requirements = m.Requirements

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		OriginalCondition string `json:"original_condition,omitempty"`
	}

	dataAO1.OriginalCondition = m.OriginalCondition

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0 version all of3 dependency sets items0 dependencies items0 conditions items0
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 v1 ingredient and version paged list ingredients and versions items0 version all of3 dependency sets items0 dependencies items0 conditions items0 requirements items0
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0 version all of3 dependency sets items0 dependencies items0 conditions items0 requirements items0
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0 v1 ingredient and version paged list ingredients and versions items0 version all of3 dependency sets items0 dependencies items0 requirements items0
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0 version all of3 dependency sets items0 dependencies items0 requirements items0
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum = append(v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorEq string = "eq"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGt string = "gt"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGte string = "gte"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLt string = "lt"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLte string = "lte"

	// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0
type V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 ingredient and version paged list ingredients and versions items0 version all of3 provided features items0
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListIngredientsAndVersionsItems0VersionAllOf3ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListLinks Paging Links
//
// Links for a model that include links for paging data
// swagger:model V1IngredientAndVersionPagedListLinks
type V1IngredientAndVersionPagedListLinks struct {

	// The URI of the first page
	// Required: true
	// Format: uri
	First *strfmt.URI `json:"first"`

	// The URI of last page
	// Required: true
	// Format: uri
	Last *strfmt.URI `json:"last"`

	// The URI of the next page
	// Format: uri
	Next strfmt.URI `json:"next,omitempty"`

	// The URI of the previous page
	// Format: uri
	Previous strfmt.URI `json:"previous,omitempty"`

	// The URI of this page
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 ingredient and version paged list links
func (m *V1IngredientAndVersionPagedListLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFirst(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrevious(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListLinks) validateFirst(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"first", "body", m.First); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"first", "body", "uri", m.First.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListLinks) validateLast(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"last", "body", m.Last); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"last", "body", "uri", m.Last.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListLinks) validateNext(formats strfmt.Registry) error {

	if swag.IsZero(m.Next) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"next", "body", "uri", m.Next.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListLinks) validatePrevious(formats strfmt.Registry) error {

	if swag.IsZero(m.Previous) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"previous", "body", "uri", m.Previous.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListLinks) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListLinks) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1IngredientAndVersionPagedListPaging Paging
//
// Paging data
// swagger:model V1IngredientAndVersionPagedListPaging
type V1IngredientAndVersionPagedListPaging struct {

	// The number of items on this page
	// Required: true
	// Minimum: 0
	ItemCount *int64 `json:"item_count"`

	// The maximum number of items that could be returned
	// Required: true
	// Minimum: 1
	Limit *int64 `json:"limit"`

	// The page number of this result set
	// Required: true
	// Minimum: 1
	Page *int64 `json:"page"`

	// The total number of pages
	// Required: true
	// Minimum: 1
	PageCount *int64 `json:"page_count"`
}

// Validate validates this v1 ingredient and version paged list paging
func (m *V1IngredientAndVersionPagedListPaging) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateItemCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePageCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1IngredientAndVersionPagedListPaging) validateItemCount(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"item_count", "body", m.ItemCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"item_count", "body", int64(*m.ItemCount), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListPaging) validateLimit(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"limit", "body", m.Limit); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"limit", "body", int64(*m.Limit), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListPaging) validatePage(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"page", "body", m.Page); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"page", "body", int64(*m.Page), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1IngredientAndVersionPagedListPaging) validatePageCount(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"page_count", "body", m.PageCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"page_count", "body", int64(*m.PageCount), 1, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListPaging) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1IngredientAndVersionPagedListPaging) UnmarshalBinary(b []byte) error {
	var res V1IngredientAndVersionPagedListPaging
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
