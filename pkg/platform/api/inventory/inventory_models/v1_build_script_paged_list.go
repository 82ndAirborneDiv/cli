// Code generated by go-swagger; DO NOT EDIT.

package inventory_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1BuildScriptPagedList Build Script Paged List
//
// A paginated list of build scripts
// swagger:model v1BuildScriptPagedList
type V1BuildScriptPagedList struct {

	// A page of build scripts
	// Required: true
	BuildScripts []*V1BuildScriptPagedListBuildScriptsItems0 `json:"build_scripts"`

	// links
	// Required: true
	Links *V1BuildScriptPagedListLinks `json:"links"`

	// paging
	// Required: true
	Paging *V1BuildScriptPagedListPaging `json:"paging"`
}

// Validate validates this v1 build script paged list
func (m *V1BuildScriptPagedList) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildScripts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaging(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildScriptPagedList) validateBuildScripts(formats strfmt.Registry) error {

	if err := validate.Required("build_scripts", "body", m.BuildScripts); err != nil {
		return err
	}

	for i := 0; i < len(m.BuildScripts); i++ {
		if swag.IsZero(m.BuildScripts[i]) { // not required
			continue
		}

		if m.BuildScripts[i] != nil {
			if err := m.BuildScripts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("build_scripts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1BuildScriptPagedList) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildScriptPagedList) validatePaging(formats strfmt.Registry) error {

	if err := validate.Required("paging", "body", m.Paging); err != nil {
		return err
	}

	if m.Paging != nil {
		if err := m.Paging.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paging")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildScriptPagedList) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildScriptPagedList) UnmarshalBinary(b []byte) error {
	var res V1BuildScriptPagedList
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildScriptPagedListBuildScriptsItems0 Build Script
//
// A short piece of scripting code that can be used to build an ingredient. This model contains all build script properties and is returned from read requests
// swagger:model V1BuildScriptPagedListBuildScriptsItems0
type V1BuildScriptPagedListBuildScriptsItems0 struct {

	// build script id
	// Required: true
	// Format: uuid
	BuildScriptID *strfmt.UUID `json:"build_script_id"`

	// creation timestamp
	// Required: true
	// Format: date-time
	CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

	// links
	// Required: true
	Links *V1BuildScriptPagedListBuildScriptsItems0AO0Links `json:"links"`

	// The features that must already be present in the recipe for this build script to be used. For example, can be used to create build scripts that only work on specific operating systems.
	Conditions []*V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0 `json:"conditions"`

	// The scripting language that the build script is written in
	// Required: true
	// Enum: [bash perl python]
	Language *string `json:"language"`

	// The build script itself
	// Required: true
	Script *string `json:"script"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1BuildScriptPagedListBuildScriptsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		BuildScriptID *strfmt.UUID `json:"build_script_id"`

		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1BuildScriptPagedListBuildScriptsItems0AO0Links `json:"links"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.BuildScriptID = dataAO0.BuildScriptID

	m.CreationTimestamp = dataAO0.CreationTimestamp

	m.Links = dataAO0.Links

	// AO1
	var dataAO1 struct {
		Conditions []*V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0 `json:"conditions,omitempty"`

		Language *string `json:"language"`

		Script *string `json:"script"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Conditions = dataAO1.Conditions

	m.Language = dataAO1.Language

	m.Script = dataAO1.Script

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1BuildScriptPagedListBuildScriptsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		BuildScriptID *strfmt.UUID `json:"build_script_id"`

		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1BuildScriptPagedListBuildScriptsItems0AO0Links `json:"links"`
	}

	dataAO0.BuildScriptID = m.BuildScriptID

	dataAO0.CreationTimestamp = m.CreationTimestamp

	dataAO0.Links = m.Links

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		Conditions []*V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0 `json:"conditions,omitempty"`

		Language *string `json:"language"`

		Script *string `json:"script"`
	}

	dataAO1.Conditions = m.Conditions

	dataAO1.Language = m.Language

	dataAO1.Script = m.Script

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 build script paged list build scripts items0
func (m *V1BuildScriptPagedListBuildScriptsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildScriptID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScript(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0) validateBuildScriptID(formats strfmt.Registry) error {

	if err := validate.Required("build_script_id", "body", m.BuildScriptID); err != nil {
		return err
	}

	if err := validate.FormatOf("build_script_id", "body", "uuid", m.BuildScriptID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0) validateCreationTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("creation_timestamp", "body", m.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("creation_timestamp", "body", "date-time", m.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var v1BuildScriptPagedListBuildScriptsItems0TypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bash","perl","python"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildScriptPagedListBuildScriptsItems0TypeLanguagePropEnum = append(v1BuildScriptPagedListBuildScriptsItems0TypeLanguagePropEnum, v)
	}
}

// property enum
func (m *V1BuildScriptPagedListBuildScriptsItems0) validateLanguageEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildScriptPagedListBuildScriptsItems0TypeLanguagePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0) validateLanguage(formats strfmt.Registry) error {

	if err := validate.Required("language", "body", m.Language); err != nil {
		return err
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", *m.Language); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0) validateScript(formats strfmt.Registry) error {

	if err := validate.Required("script", "body", m.Script); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildScriptPagedListBuildScriptsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildScriptPagedListBuildScriptsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildScriptPagedListBuildScriptsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildScriptPagedListBuildScriptsItems0AO0Links Self Link
//
// A self link
// swagger:model V1BuildScriptPagedListBuildScriptsItems0AO0Links
type V1BuildScriptPagedListBuildScriptsItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build script paged list build scripts items0 a o0 links
func (m *V1BuildScriptPagedListBuildScriptsItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildScriptPagedListBuildScriptsItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildScriptPagedListBuildScriptsItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1BuildScriptPagedListBuildScriptsItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0
type V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 build script paged list build scripts items0 conditions items0
func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0 v1 build script paged list build scripts items0 conditions items0 requirements items0
// swagger:model V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0
type V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 build script paged list build scripts items0 conditions items0 requirements items0
func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1BuildScriptPagedListBuildScriptsItems0ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildScriptPagedListLinks Paging Links
//
// Links for a model that include links for paging data
// swagger:model V1BuildScriptPagedListLinks
type V1BuildScriptPagedListLinks struct {

	// The URI of the first page
	// Required: true
	// Format: uri
	First *strfmt.URI `json:"first"`

	// The URI of last page
	// Required: true
	// Format: uri
	Last *strfmt.URI `json:"last"`

	// The URI of the next page
	// Format: uri
	Next strfmt.URI `json:"next,omitempty"`

	// The URI of the previous page
	// Format: uri
	Previous strfmt.URI `json:"previous,omitempty"`

	// The URI of this page
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 build script paged list links
func (m *V1BuildScriptPagedListLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFirst(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrevious(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildScriptPagedListLinks) validateFirst(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"first", "body", m.First); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"first", "body", "uri", m.First.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListLinks) validateLast(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"last", "body", m.Last); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"last", "body", "uri", m.Last.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListLinks) validateNext(formats strfmt.Registry) error {

	if swag.IsZero(m.Next) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"next", "body", "uri", m.Next.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListLinks) validatePrevious(formats strfmt.Registry) error {

	if swag.IsZero(m.Previous) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"previous", "body", "uri", m.Previous.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListLinks) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildScriptPagedListLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildScriptPagedListLinks) UnmarshalBinary(b []byte) error {
	var res V1BuildScriptPagedListLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1BuildScriptPagedListPaging Paging
//
// Paging data
// swagger:model V1BuildScriptPagedListPaging
type V1BuildScriptPagedListPaging struct {

	// The number of items on this page
	// Required: true
	// Minimum: 0
	ItemCount *int64 `json:"item_count"`

	// The maximum number of items that could be returned
	// Required: true
	// Minimum: 1
	Limit *int64 `json:"limit"`

	// The page number of this result set
	// Required: true
	// Minimum: 1
	Page *int64 `json:"page"`

	// The total number of pages
	// Required: true
	// Minimum: 1
	PageCount *int64 `json:"page_count"`
}

// Validate validates this v1 build script paged list paging
func (m *V1BuildScriptPagedListPaging) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateItemCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePageCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1BuildScriptPagedListPaging) validateItemCount(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"item_count", "body", m.ItemCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"item_count", "body", int64(*m.ItemCount), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListPaging) validateLimit(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"limit", "body", m.Limit); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"limit", "body", int64(*m.Limit), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListPaging) validatePage(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"page", "body", m.Page); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"page", "body", int64(*m.Page), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1BuildScriptPagedListPaging) validatePageCount(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"page_count", "body", m.PageCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"page_count", "body", int64(*m.PageCount), 1, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1BuildScriptPagedListPaging) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1BuildScriptPagedListPaging) UnmarshalBinary(b []byte) error {
	var res V1BuildScriptPagedListPaging
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
