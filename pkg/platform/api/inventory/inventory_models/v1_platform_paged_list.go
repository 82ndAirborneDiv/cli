// Code generated by go-swagger; DO NOT EDIT.

package inventory_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1PlatformPagedList Platform Paged List
//
// A paginated list of platforms
// swagger:model v1PlatformPagedList
type V1PlatformPagedList struct {

	// links
	// Required: true
	Links *V1PlatformPagedListLinks `json:"links"`

	// paging
	// Required: true
	Paging *V1PlatformPagedListPaging `json:"paging"`

	// A page of platforms
	// Required: true
	Platforms []*V1PlatformPagedListPlatformsItems0 `json:"platforms"`
}

// Validate validates this v1 platform paged list
func (m *V1PlatformPagedList) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaging(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatforms(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedList) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1PlatformPagedList) validatePaging(formats strfmt.Registry) error {

	if err := validate.Required("paging", "body", m.Paging); err != nil {
		return err
	}

	if m.Paging != nil {
		if err := m.Paging.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paging")
			}
			return err
		}
	}

	return nil
}

func (m *V1PlatformPagedList) validatePlatforms(formats strfmt.Registry) error {

	if err := validate.Required("platforms", "body", m.Platforms); err != nil {
		return err
	}

	for i := 0; i < len(m.Platforms); i++ {
		if swag.IsZero(m.Platforms[i]) { // not required
			continue
		}

		if m.Platforms[i] != nil {
			if err := m.Platforms[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("platforms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedList) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedList) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedList
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListLinks Paging Links
//
// Links for a model that include links for paging data
// swagger:model V1PlatformPagedListLinks
type V1PlatformPagedListLinks struct {

	// The URI of the first page
	// Required: true
	// Format: uri
	First *strfmt.URI `json:"first"`

	// The URI of last page
	// Required: true
	// Format: uri
	Last *strfmt.URI `json:"last"`

	// The URI of the next page
	// Format: uri
	Next strfmt.URI `json:"next,omitempty"`

	// The URI of the previous page
	// Format: uri
	Previous strfmt.URI `json:"previous,omitempty"`

	// The URI of this page
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list links
func (m *V1PlatformPagedListLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFirst(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrevious(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListLinks) validateFirst(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"first", "body", m.First); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"first", "body", "uri", m.First.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListLinks) validateLast(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"last", "body", m.Last); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"last", "body", "uri", m.Last.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListLinks) validateNext(formats strfmt.Registry) error {

	if swag.IsZero(m.Next) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"next", "body", "uri", m.Next.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListLinks) validatePrevious(formats strfmt.Registry) error {

	if swag.IsZero(m.Previous) { // not required
		return nil
	}

	if err := validate.FormatOf("links"+"."+"previous", "body", "uri", m.Previous.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListLinks) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListLinks) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPaging Paging
//
// Paging data
// swagger:model V1PlatformPagedListPaging
type V1PlatformPagedListPaging struct {

	// The number of items on this page
	// Required: true
	// Minimum: 0
	ItemCount *int64 `json:"item_count"`

	// The maximum number of items that could be returned
	// Required: true
	// Minimum: 1
	Limit *int64 `json:"limit"`

	// The page number of this result set
	// Required: true
	// Minimum: 1
	Page *int64 `json:"page"`

	// The total number of pages
	// Required: true
	// Minimum: 1
	PageCount *int64 `json:"page_count"`
}

// Validate validates this v1 platform paged list paging
func (m *V1PlatformPagedListPaging) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateItemCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePageCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPaging) validateItemCount(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"item_count", "body", m.ItemCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"item_count", "body", int64(*m.ItemCount), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPaging) validateLimit(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"limit", "body", m.Limit); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"limit", "body", int64(*m.Limit), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPaging) validatePage(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"page", "body", m.Page); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"page", "body", int64(*m.Page), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPaging) validatePageCount(formats strfmt.Registry) error {

	if err := validate.Required("paging"+"."+"page_count", "body", m.PageCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("paging"+"."+"page_count", "body", int64(*m.PageCount), 1, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPaging) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPaging) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPaging
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0 Platform
//
// A platform upon which a build can be built.
// swagger:model V1PlatformPagedListPlatformsItems0
type V1PlatformPagedListPlatformsItems0 struct {

	// CPU Architecture
	//
	// The full CPU architecture data model
	// Required: true
	CPUArchitecture struct {

		// cpu architecture id
		// Required: true
		// Format: uuid
		CPUArchitectureID *strfmt.UUID `json:"cpu_architecture_id"`

		// links
		// Required: true
		Links *V1PlatformPagedListPlatformsItems0CPUArchitectureAO0Links `json:"links"`

		V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"cpu_architecture"`

	// cpu extensions
	CPUExtensions []*V1PlatformPagedListPlatformsItems0CPUExtensionsItems0 `json:"cpu_extensions"`

	// The date and time this platform was created.
	// Required: true
	// Format: date-time
	CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

	// display name
	// Required: true
	DisplayName *string `json:"display_name"`

	// The last day on which this platform will be supported. Can be omitted if no last day has yet been determined.
	// Format: date
	EndOfSupportDate *strfmt.Date `json:"end_of_support_date,omitempty"`

	// GPU Architecture
	//
	// The full GPU architecture data model
	GpuArchitecture struct {

		// gpu architecture id
		// Required: true
		// Format: uuid
		GpuArchitectureID *strfmt.UUID `json:"gpu_architecture_id"`

		// links
		// Required: true
		Links *V1PlatformPagedListPlatformsItems0GpuArchitectureAO0Links `json:"links"`

		V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"gpu_architecture,omitempty"`

	// images
	// Required: true
	Images []*V1PlatformPagedListPlatformsItems0ImagesItems0 `json:"images"`

	// If true, the platform should be shown to the user as a selectable platform for an order. If false, the platform should be hidden from the user.
	IsUserVisible *bool `json:"is_user_visible,omitempty"`

	// Kernel
	//
	// The full kernel data model
	// Required: true
	Kernel struct {

		// kernel id
		// Required: true
		// Format: uuid
		KernelID *strfmt.UUID `json:"kernel_id"`

		// links
		// Required: true
		Links *V1PlatformPagedListPlatformsItems0KernelAO0Links `json:"links"`

		// The name of the kernel (excluding any version information)
		// Required: true
		Name *string `json:"name"`
	} `json:"kernel"`

	// Kernel Version
	//
	// The full kernel version data model
	// Required: true
	KernelVersion struct {

		// kernel version id
		// Required: true
		// Format: uuid
		KernelVersionID *strfmt.UUID `json:"kernel_version_id"`

		// links
		// Required: true
		Links *V1PlatformPagedListPlatformsItems0KernelVersionAO0Links `json:"links"`

		V1PlatformPagedListPlatformsItems0KernelVersionAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"kernel_version"`

	// Libc
	//
	// The full libc data model
	Libc struct {

		// libc id
		// Required: true
		// Format: uuid
		LibcID *strfmt.UUID `json:"libc_id"`

		// links
		// Required: true
		Links *V1PlatformPagedListPlatformsItems0LibcAO0Links `json:"links"`

		// The name of the libc (excluding any version information)
		// Required: true
		Name *string `json:"name"`
	} `json:"libc,omitempty"`

	// Libc Version
	//
	// The full libc version data model
	LibcVersion struct {

		// libc version id
		// Required: true
		// Format: uuid
		LibcVersionID *strfmt.UUID `json:"libc_version_id"`

		// links
		// Required: true
		Links *V1PlatformPagedListPlatformsItems0LibcVersionAO0Links `json:"links"`

		V1PlatformPagedListPlatformsItems0LibcVersionAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"libc_version,omitempty"`

	// links
	// Required: true
	Links *V1PlatformPagedListPlatformsItems0Links `json:"links"`

	// Operating System
	//
	// The full operating system data model
	// Required: true
	OperatingSystem struct {

		// links
		// Required: true
		Links *V1PlatformPagedListPlatformsItems0OperatingSystemAO0Links `json:"links"`

		// operating system id
		// Required: true
		// Format: uuid
		OperatingSystemID *strfmt.UUID `json:"operating_system_id"`

		// Whether an implementation of libc is considered a core feature of the OS. This is generally true for *nix OSes and false for others.
		// Required: true
		HasLibc *bool `json:"has_libc"`

		// The name of the operating system (excluding any version information). This should be more specific than just an OS class (e.g. 'Red Star OS' rather than just 'Linux')
		// Required: true
		Name *string `json:"name"`
	} `json:"operating_system"`

	// Operating System Version
	//
	// The full operating system version data model
	// Required: true
	OperatingSystemVersion struct {

		// links
		// Required: true
		Links *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAO0Links `json:"links"`

		// operating system version id
		// Required: true
		// Format: uuid
		OperatingSystemVersionID *strfmt.UUID `json:"operating_system_version_id"`

		V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"operating_system_version"`

	// platform id
	// Required: true
	// Format: uuid
	PlatformID *strfmt.UUID `json:"platform_id"`
}

// Validate validates this v1 platform paged list platforms items0
func (m *V1PlatformPagedListPlatformsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPUArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCPUExtensions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndOfSupportDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKernel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKernelVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLibc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLibcVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperatingSystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperatingSystemVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateCPUArchitecture(formats strfmt.Registry) error {

	if err := validate.Required("cpu_architecture"+"."+"cpu_architecture_id", "body", m.CPUArchitecture.CPUArchitectureID); err != nil {
		return err
	}

	if err := validate.FormatOf("cpu_architecture"+"."+"cpu_architecture_id", "body", "uuid", m.CPUArchitecture.CPUArchitectureID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("cpu_architecture"+"."+"links", "body", m.CPUArchitecture.Links); err != nil {
		return err
	}

	if m.CPUArchitecture.Links != nil {
		if err := m.CPUArchitecture.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cpu_architecture" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("cpu_architecture"+"."+"revision", "body", m.CPUArchitecture.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("cpu_architecture"+"."+"revision", "body", int64(*m.CPUArchitecture.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("cpu_architecture"+"."+"revision_timestamp", "body", m.CPUArchitecture.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("cpu_architecture"+"."+"revision_timestamp", "body", "date-time", m.CPUArchitecture.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateCPUExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.CPUExtensions) { // not required
		return nil
	}

	for i := 0; i < len(m.CPUExtensions); i++ {
		if swag.IsZero(m.CPUExtensions[i]) { // not required
			continue
		}

		if m.CPUExtensions[i] != nil {
			if err := m.CPUExtensions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cpu_extensions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateCreationTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("creation_timestamp", "body", m.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("creation_timestamp", "body", "date-time", m.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateDisplayName(formats strfmt.Registry) error {

	if err := validate.Required("display_name", "body", m.DisplayName); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateEndOfSupportDate(formats strfmt.Registry) error {

	if swag.IsZero(m.EndOfSupportDate) { // not required
		return nil
	}

	if err := validate.FormatOf("end_of_support_date", "body", "date", m.EndOfSupportDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateGpuArchitecture(formats strfmt.Registry) error {

	if swag.IsZero(m.GpuArchitecture) { // not required
		return nil
	}

	if err := validate.Required("gpu_architecture"+"."+"gpu_architecture_id", "body", m.GpuArchitecture.GpuArchitectureID); err != nil {
		return err
	}

	if err := validate.FormatOf("gpu_architecture"+"."+"gpu_architecture_id", "body", "uuid", m.GpuArchitecture.GpuArchitectureID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("gpu_architecture"+"."+"links", "body", m.GpuArchitecture.Links); err != nil {
		return err
	}

	if m.GpuArchitecture.Links != nil {
		if err := m.GpuArchitecture.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gpu_architecture" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("gpu_architecture"+"."+"revision", "body", m.GpuArchitecture.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("gpu_architecture"+"."+"revision", "body", int64(*m.GpuArchitecture.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("gpu_architecture"+"."+"revision_timestamp", "body", m.GpuArchitecture.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("gpu_architecture"+"."+"revision_timestamp", "body", "date-time", m.GpuArchitecture.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateImages(formats strfmt.Registry) error {

	if err := validate.Required("images", "body", m.Images); err != nil {
		return err
	}

	for i := 0; i < len(m.Images); i++ {
		if swag.IsZero(m.Images[i]) { // not required
			continue
		}

		if m.Images[i] != nil {
			if err := m.Images[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("images" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateKernel(formats strfmt.Registry) error {

	if err := validate.Required("kernel"+"."+"kernel_id", "body", m.Kernel.KernelID); err != nil {
		return err
	}

	if err := validate.FormatOf("kernel"+"."+"kernel_id", "body", "uuid", m.Kernel.KernelID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("kernel"+"."+"links", "body", m.Kernel.Links); err != nil {
		return err
	}

	if m.Kernel.Links != nil {
		if err := m.Kernel.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kernel" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("kernel"+"."+"name", "body", m.Kernel.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateKernelVersion(formats strfmt.Registry) error {

	if err := validate.Required("kernel_version"+"."+"kernel_version_id", "body", m.KernelVersion.KernelVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("kernel_version"+"."+"kernel_version_id", "body", "uuid", m.KernelVersion.KernelVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("kernel_version"+"."+"links", "body", m.KernelVersion.Links); err != nil {
		return err
	}

	if m.KernelVersion.Links != nil {
		if err := m.KernelVersion.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kernel_version" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("kernel_version"+"."+"revision", "body", m.KernelVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("kernel_version"+"."+"revision", "body", int64(*m.KernelVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("kernel_version"+"."+"revision_timestamp", "body", m.KernelVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("kernel_version"+"."+"revision_timestamp", "body", "date-time", m.KernelVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateLibc(formats strfmt.Registry) error {

	if swag.IsZero(m.Libc) { // not required
		return nil
	}

	if err := validate.Required("libc"+"."+"libc_id", "body", m.Libc.LibcID); err != nil {
		return err
	}

	if err := validate.FormatOf("libc"+"."+"libc_id", "body", "uuid", m.Libc.LibcID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("libc"+"."+"links", "body", m.Libc.Links); err != nil {
		return err
	}

	if m.Libc.Links != nil {
		if err := m.Libc.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libc" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("libc"+"."+"name", "body", m.Libc.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateLibcVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.LibcVersion) { // not required
		return nil
	}

	if err := validate.Required("libc_version"+"."+"libc_version_id", "body", m.LibcVersion.LibcVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("libc_version"+"."+"libc_version_id", "body", "uuid", m.LibcVersion.LibcVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("libc_version"+"."+"links", "body", m.LibcVersion.Links); err != nil {
		return err
	}

	if m.LibcVersion.Links != nil {
		if err := m.LibcVersion.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("libc_version" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("libc_version"+"."+"revision", "body", m.LibcVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("libc_version"+"."+"revision", "body", int64(*m.LibcVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("libc_version"+"."+"revision_timestamp", "body", m.LibcVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("libc_version"+"."+"revision_timestamp", "body", "date-time", m.LibcVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateOperatingSystem(formats strfmt.Registry) error {

	if err := validate.Required("operating_system"+"."+"links", "body", m.OperatingSystem.Links); err != nil {
		return err
	}

	if m.OperatingSystem.Links != nil {
		if err := m.OperatingSystem.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("operating_system" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("operating_system"+"."+"operating_system_id", "body", m.OperatingSystem.OperatingSystemID); err != nil {
		return err
	}

	if err := validate.FormatOf("operating_system"+"."+"operating_system_id", "body", "uuid", m.OperatingSystem.OperatingSystemID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("operating_system"+"."+"has_libc", "body", m.OperatingSystem.HasLibc); err != nil {
		return err
	}

	if err := validate.Required("operating_system"+"."+"name", "body", m.OperatingSystem.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validateOperatingSystemVersion(formats strfmt.Registry) error {

	if err := validate.Required("operating_system_version"+"."+"links", "body", m.OperatingSystemVersion.Links); err != nil {
		return err
	}

	if m.OperatingSystemVersion.Links != nil {
		if err := m.OperatingSystemVersion.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("operating_system_version" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("operating_system_version"+"."+"operating_system_version_id", "body", m.OperatingSystemVersion.OperatingSystemVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("operating_system_version"+"."+"operating_system_version_id", "body", "uuid", m.OperatingSystemVersion.OperatingSystemVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("operating_system_version"+"."+"revision", "body", m.OperatingSystemVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("operating_system_version"+"."+"revision", "body", int64(*m.OperatingSystemVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("operating_system_version"+"."+"revision_timestamp", "body", m.OperatingSystemVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("operating_system_version"+"."+"revision_timestamp", "body", "date-time", m.OperatingSystemVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform_id", "body", "uuid", m.PlatformID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0CPUArchitectureAO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0CPUArchitectureAO0Links
type V1PlatformPagedListPlatformsItems0CPUArchitectureAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 CPU architecture a o0 links
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("cpu_architecture"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("cpu_architecture"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0CPUArchitectureAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1 CPU Architecture Core
//
// The properties of a CPU architecture needed to create a new one
// swagger:model V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1
type V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1 struct {

	// bit width
	// Enum: [32 64]
	BitWidth string `json:"bit_width,omitempty"`

	// The name of the CPU architecture
	// Required: true
	Name *string `json:"name"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		BitWidth string `json:"bit_width,omitempty"`

		Name *string `json:"name"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.BitWidth = dataAO0.BitWidth

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		BitWidth string `json:"bit_width,omitempty"`

		Name *string `json:"name"`
	}

	dataAO0.BitWidth = m.BitWidth

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 CPU architecture all of1
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBitWidth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1PlatformPagedListPlatformsItems0CpuArchitectureAllOf1TypeBitWidthPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["32","64"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1PlatformPagedListPlatformsItems0CpuArchitectureAllOf1TypeBitWidthPropEnum = append(v1PlatformPagedListPlatformsItems0CpuArchitectureAllOf1TypeBitWidthPropEnum, v)
	}
}

// property enum
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1) validateBitWidthEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1PlatformPagedListPlatformsItems0CpuArchitectureAllOf1TypeBitWidthPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1) validateBitWidth(formats strfmt.Registry) error {

	if swag.IsZero(m.BitWidth) { // not required
		return nil
	}

	// value enum
	if err := m.validateBitWidthEnum("bit_width", "body", m.BitWidth); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0
type V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 CPU architecture all of1 provided features items0
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0CPUArchitectureAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0CPUExtensionsItems0 CPU Extension
//
// The full CPU extension data model
// swagger:model V1PlatformPagedListPlatformsItems0CPUExtensionsItems0
type V1PlatformPagedListPlatformsItems0CPUExtensionsItems0 struct {

	// cpu extension id
	// Required: true
	// Format: uuid
	CPUExtensionID *strfmt.UUID `json:"cpu_extension_id"`

	// links
	// Required: true
	Links *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links `json:"links"`

	V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1

	// The revision number of this revision of the resource. This number increases monotonically with each new revision.
	// Required: true
	// Minimum: 1
	Revision *int64 `json:"revision"`

	// The date and time at which this revision of the resource was created
	// Required: true
	// Format: date-time
	RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CPUExtensionID *strfmt.UUID `json:"cpu_extension_id"`

		Links *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links `json:"links"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CPUExtensionID = dataAO0.CPUExtensionID

	m.Links = dataAO0.Links

	// AO1
	var aO1 V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1 = aO1

	// AO2
	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Revision = dataAO2.Revision

	m.RevisionTimestamp = dataAO2.RevisionTimestamp

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0CPUExtensionsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		CPUExtensionID *strfmt.UUID `json:"cpu_extension_id"`

		Links *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links `json:"links"`
	}

	dataAO0.CPUExtensionID = m.CPUExtensionID

	dataAO0.Links = m.Links

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}

	dataAO2.Revision = m.Revision

	dataAO2.RevisionTimestamp = m.RevisionTimestamp

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 CPU extensions items0
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPUExtensionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1
	if err := m.V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevisionTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0) validateCPUExtensionID(formats strfmt.Registry) error {

	if err := validate.Required("cpu_extension_id", "body", m.CPUExtensionID); err != nil {
		return err
	}

	if err := validate.FormatOf("cpu_extension_id", "body", "uuid", m.CPUExtensionID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0) validateRevision(formats strfmt.Registry) error {

	if err := validate.Required("revision", "body", m.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("revision", "body", int64(*m.Revision), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0) validateRevisionTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("revision_timestamp", "body", m.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("revision_timestamp", "body", "date-time", m.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0CPUExtensionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links
type V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 CPU extensions items0 a o0 links
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1 CPU Extension Core
//
// The properties of a CPU extension needed to create a new one
// swagger:model V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1
type V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1 struct {

	// The name of the CPU extension
	// Required: true
	Name *string `json:"name"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`
	}

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 CPU extensions items0 all of1
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0
type V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 CPU extensions items0 all of1 provided features items0
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0CPUExtensionsItems0AllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0GpuArchitectureAO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0GpuArchitectureAO0Links
type V1PlatformPagedListPlatformsItems0GpuArchitectureAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 gpu architecture a o0 links
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("gpu_architecture"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("gpu_architecture"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0GpuArchitectureAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1 GPU Architecture Core
//
// The properties of a GPU architecture needed to create a new one
// swagger:model V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1
type V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1 struct {

	// The name of the GPU architecture
	// Required: true
	Name *string `json:"name"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`
	}

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 gpu architecture all of1
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0
type V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 gpu architecture all of1 provided features items0
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0GpuArchitectureAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0ImagesItems0 Image
//
// The full image data model
// swagger:model V1PlatformPagedListPlatformsItems0ImagesItems0
type V1PlatformPagedListPlatformsItems0ImagesItems0 struct {

	// image id
	// Required: true
	// Format: uuid
	ImageID *strfmt.UUID `json:"image_id"`

	// links
	// Required: true
	Links *V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links `json:"links"`

	V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1

	// The revision number of this revision of the resource. This number increases monotonically with each new revision.
	// Required: true
	// Minimum: 1
	Revision *int64 `json:"revision"`

	// The date and time at which this revision of the resource was created
	// Required: true
	// Format: date-time
	RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		ImageID *strfmt.UUID `json:"image_id"`

		Links *V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links `json:"links"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.ImageID = dataAO0.ImageID

	m.Links = dataAO0.Links

	// AO1
	var aO1 V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1 = aO1

	// AO2
	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Revision = dataAO2.Revision

	m.RevisionTimestamp = dataAO2.RevisionTimestamp

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0ImagesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		ImageID *strfmt.UUID `json:"image_id"`

		Links *V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links `json:"links"`
	}

	dataAO0.ImageID = m.ImageID

	dataAO0.Links = m.Links

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}

	dataAO2.Revision = m.Revision

	dataAO2.RevisionTimestamp = m.RevisionTimestamp

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 images items0
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateImageID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1
	if err := m.V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevisionTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0) validateImageID(formats strfmt.Registry) error {

	if err := validate.Required("image_id", "body", m.ImageID); err != nil {
		return err
	}

	if err := validate.FormatOf("image_id", "body", "uuid", m.ImageID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0) validateRevision(formats strfmt.Registry) error {

	if err := validate.Required("revision", "body", m.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("revision", "body", int64(*m.Revision), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0) validateRevisionTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("revision_timestamp", "body", m.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("revision_timestamp", "body", "date-time", m.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0ImagesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links
type V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 images items0 a o0 links
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0ImagesItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1 Image Core
//
// The properties of an image needed to create a new one
// swagger:model V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1
type V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1 struct {

	// The name of the image (excluding any version information). This will be something like "activestate/centos-6.9-build" (for a Docker image) or "ami-foo-12345" (WindowsInstance).
	// Required: true
	Name *string `json:"name"`

	// The platform to which this image belongs.
	// Required: true
	PlatformID *string `json:"platform_id"`

	// The type of the image.
	// Required: true
	// Enum: [Docker WindowsInstance]
	Type *string `json:"type"`

	V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	m.PlatformID = dataAO0.PlatformID

	m.Type = dataAO0.Type

	// AO1
	var aO1 V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1 = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}

	dataAO0.Name = m.Name

	dataAO0.PlatformID = m.PlatformID

	dataAO0.Type = m.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 images items0 all of1
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1
	if err := m.V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	return nil
}

var v1PlatformPagedListPlatformsItems0ImagesItems0AllOf1TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Docker","WindowsInstance"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1PlatformPagedListPlatformsItems0ImagesItems0AllOf1TypeTypePropEnum = append(v1PlatformPagedListPlatformsItems0ImagesItems0AllOf1TypeTypePropEnum, v)
	}
}

// property enum
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1PlatformPagedListPlatformsItems0ImagesItems0AllOf1TypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1 Image Revision Core
//
// The properties of an image revision needed to create a new one
// swagger:model V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1
type V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`

	// conditions
	Conditions []*V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0 `json:"conditions"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	// AO2
	var dataAO2 struct {
		Conditions []*V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Conditions = dataAO2.Conditions

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	var dataAO2 struct {
		Conditions []*V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}

	dataAO2.Conditions = m.Conditions

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 images items0 all of1 all of1
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0
type V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 platform paged list platforms items0 images items0 all of1 all of1 conditions items0
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0 v1 platform paged list platforms items0 images items0 all of1 all of1 conditions items0 requirements items0
// swagger:model V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0
type V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 platform paged list platforms items0 images items0 all of1 all of1 conditions items0 requirements items0
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0
type V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 images items0 all of1 all of1 provided features items0
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0ImagesItems0AllOf1AllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0KernelAO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0KernelAO0Links
type V1PlatformPagedListPlatformsItems0KernelAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 kernel a o0 links
func (m *V1PlatformPagedListPlatformsItems0KernelAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("kernel"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("kernel"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0KernelAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0KernelAO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0KernelAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0KernelVersionAO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0KernelVersionAO0Links
type V1PlatformPagedListPlatformsItems0KernelVersionAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 kernel version a o0 links
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelVersionAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("kernel_version"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("kernel_version"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0KernelVersionAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0KernelVersionAllOf1 Kernel Version Core
//
// The properties of a kernel version needed to create a new one
// swagger:model V1PlatformPagedListPlatformsItems0KernelVersionAllOf1
type V1PlatformPagedListPlatformsItems0KernelVersionAllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0KernelVersionAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 kernel version all of1
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0KernelVersionAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0
type V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 kernel version all of1 provided features items0
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0KernelVersionAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0LibcAO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0LibcAO0Links
type V1PlatformPagedListPlatformsItems0LibcAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 libc a o0 links
func (m *V1PlatformPagedListPlatformsItems0LibcAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("libc"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("libc"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0LibcAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0LibcAO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0LibcAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0LibcVersionAO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0LibcVersionAO0Links
type V1PlatformPagedListPlatformsItems0LibcVersionAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 libc version a o0 links
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcVersionAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("libc_version"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("libc_version"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0LibcVersionAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0LibcVersionAllOf1 Libc Version Core
//
// The properties of a libc version needed to create a new one
// swagger:model V1PlatformPagedListPlatformsItems0LibcVersionAllOf1
type V1PlatformPagedListPlatformsItems0LibcVersionAllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0LibcVersionAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 libc version all of1
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0LibcVersionAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0
type V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 libc version all of1 provided features items0
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0LibcVersionAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0Links
type V1PlatformPagedListPlatformsItems0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 links
func (m *V1PlatformPagedListPlatformsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0OperatingSystemAO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0OperatingSystemAO0Links
type V1PlatformPagedListPlatformsItems0OperatingSystemAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 operating system a o0 links
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("operating_system"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("operating_system"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemAO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0OperatingSystemAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0OperatingSystemVersionAO0Links Self Link
//
// A self link
// swagger:model V1PlatformPagedListPlatformsItems0OperatingSystemVersionAO0Links
type V1PlatformPagedListPlatformsItems0OperatingSystemVersionAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 platform paged list platforms items0 operating system version a o0 links
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("operating_system_version"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("operating_system_version"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAO0Links) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0OperatingSystemVersionAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1 Operating System Version Core
//
// The properties of an operating system version needed to create a new one
// swagger:model V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1
type V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 operating system version all of1
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0
type V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 platform paged list platforms items0 operating system version all of1 provided features items0
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1PlatformPagedListPlatformsItems0OperatingSystemVersionAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
