// Code generated by go-swagger; DO NOT EDIT.

package inventory_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1RecipeResponse Recipe Response
//
// The response to an order. It is a list of recipes satisfying the order.
// swagger:model v1RecipeResponse
type V1RecipeResponse struct {

	// UUID of the order for which this is a response.
	// Required: true
	// Format: uuid
	OrderID *strfmt.UUID `json:"order_id"`

	// List of resolved recipes by platform for a given order
	// Required: true
	// Min Length: 1
	Recipes []*V1RecipeResponseRecipesItems0 `json:"recipes"`
}

// Validate validates this v1 recipe response
func (m *V1RecipeResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOrderID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponse) validateOrderID(formats strfmt.Registry) error {

	if err := validate.Required("order_id", "body", m.OrderID); err != nil {
		return err
	}

	if err := validate.FormatOf("order_id", "body", "uuid", m.OrderID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponse) validateRecipes(formats strfmt.Registry) error {

	if err := validate.Required("recipes", "body", m.Recipes); err != nil {
		return err
	}

	for i := 0; i < len(m.Recipes); i++ {
		if swag.IsZero(m.Recipes[i]) { // not required
			continue
		}

		if m.Recipes[i] != nil {
			if err := m.Recipes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recipes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponse) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0 Recipe
//
// A recipe contains all required information (ingredient versions, platform, build options, etc.) to build a project for a single platform.
// swagger:model V1RecipeResponseRecipesItems0
type V1RecipeResponseRecipesItems0 struct {

	// Camel-specific flags for controlling the build.
	CamelFlags []string `json:"camel_flags"`

	// Image
	//
	// The full image data model
	// Required: true
	Image struct {

		// image id
		// Required: true
		// Format: uuid
		ImageID *strfmt.UUID `json:"image_id"`

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0ImageAO0Links `json:"links"`

		V1RecipeResponseRecipesItems0ImageAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"image"`

	// platform
	// Required: true
	Platform *V1RecipeResponseRecipesItems0Platform `json:"platform"`

	// This recipe's ID. Identical recipes will have the same ID.
	// Required: true
	// Format: uuid
	RecipeID *strfmt.UUID `json:"recipe_id"`

	// The resolved ingredients that comprise this recipe.
	// Required: true
	// Min Items: 1
	// Unique: true
	ResolvedIngredients []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0 `json:"resolved_ingredients"`
}

// Validate validates this v1 recipe response recipes items0
func (m *V1RecipeResponseRecipesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateImage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatform(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolvedIngredients(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0) validateImage(formats strfmt.Registry) error {

	if err := validate.Required("image"+"."+"image_id", "body", m.Image.ImageID); err != nil {
		return err
	}

	if err := validate.FormatOf("image"+"."+"image_id", "body", "uuid", m.Image.ImageID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("image"+"."+"links", "body", m.Image.Links); err != nil {
		return err
	}

	if m.Image.Links != nil {
		if err := m.Image.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("image" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("image"+"."+"revision", "body", m.Image.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("image"+"."+"revision", "body", int64(*m.Image.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("image"+"."+"revision_timestamp", "body", m.Image.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("image"+"."+"revision_timestamp", "body", "date-time", m.Image.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0) validatePlatform(formats strfmt.Registry) error {

	if err := validate.Required("platform", "body", m.Platform); err != nil {
		return err
	}

	if m.Platform != nil {
		if err := m.Platform.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform")
			}
			return err
		}
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0) validateRecipeID(formats strfmt.Registry) error {

	if err := validate.Required("recipe_id", "body", m.RecipeID); err != nil {
		return err
	}

	if err := validate.FormatOf("recipe_id", "body", "uuid", m.RecipeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0) validateResolvedIngredients(formats strfmt.Registry) error {

	if err := validate.Required("resolved_ingredients", "body", m.ResolvedIngredients); err != nil {
		return err
	}

	iResolvedIngredientsSize := int64(len(m.ResolvedIngredients))

	if err := validate.MinItems("resolved_ingredients", "body", iResolvedIngredientsSize, 1); err != nil {
		return err
	}

	if err := validate.UniqueItems("resolved_ingredients", "body", m.ResolvedIngredients); err != nil {
		return err
	}

	for i := 0; i < len(m.ResolvedIngredients); i++ {
		if swag.IsZero(m.ResolvedIngredients[i]) { // not required
			continue
		}

		if m.ResolvedIngredients[i] != nil {
			if err := m.ResolvedIngredients[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resolved_ingredients" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ImageAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0ImageAO0Links
type V1RecipeResponseRecipesItems0ImageAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 image a o0 links
func (m *V1RecipeResponseRecipesItems0ImageAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("image"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("image"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ImageAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ImageAllOf1 Image Core
//
// The properties of an image needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0ImageAllOf1
type V1RecipeResponseRecipesItems0ImageAllOf1 struct {

	// The name of the image (excluding any version information). This will be something like "activestate/centos-6.9-build" (for a Docker image) or "ami-foo-12345" (WindowsInstance).
	// Required: true
	Name *string `json:"name"`

	// The platform to which this image belongs.
	// Required: true
	PlatformID *string `json:"platform_id"`

	// The type of the image.
	// Required: true
	// Enum: [Docker WindowsInstance]
	Type *string `json:"type"`

	V1RecipeResponseRecipesItems0ImageAllOf1AllOf1
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0ImageAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	m.PlatformID = dataAO0.PlatformID

	m.Type = dataAO0.Type

	// AO1
	var aO1 V1RecipeResponseRecipesItems0ImageAllOf1AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1RecipeResponseRecipesItems0ImageAllOf1AllOf1 = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0ImageAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}

	dataAO0.Name = m.Name

	dataAO0.PlatformID = m.PlatformID

	dataAO0.Type = m.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1RecipeResponseRecipesItems0ImageAllOf1AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 image all of1
func (m *V1RecipeResponseRecipesItems0ImageAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1RecipeResponseRecipesItems0ImageAllOf1AllOf1
	if err := m.V1RecipeResponseRecipesItems0ImageAllOf1AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	return nil
}

var v1RecipeResponseRecipesItems0ImageAllOf1TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Docker","WindowsInstance"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ImageAllOf1TypeTypePropEnum = append(v1RecipeResponseRecipesItems0ImageAllOf1TypeTypePropEnum, v)
	}
}

// property enum
func (m *V1RecipeResponseRecipesItems0ImageAllOf1) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ImageAllOf1TypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ImageAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1 Image Revision Core
//
// The properties of an image revision needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0ImageAllOf1AllOf1
type V1RecipeResponseRecipesItems0ImageAllOf1AllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`

	// conditions
	Conditions []*V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0 `json:"conditions"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	// AO2
	var dataAO2 struct {
		Conditions []*V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Conditions = dataAO2.Conditions

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0ImageAllOf1AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	var dataAO2 struct {
		Conditions []*V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}

	dataAO2.Conditions = m.Conditions

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 image all of1 all of1
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ImageAllOf1AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0
type V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 recipe response recipes items0 image all of1 all of1 conditions items0
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0 v1 recipe response recipes items0 image all of1 all of1 conditions items0 requirements items0
// swagger:model V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0
type V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 recipe response recipes items0 image all of1 all of1 conditions items0 requirements items0
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0
type V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 image all of1 all of1 provided features items0
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ImageAllOf1AllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0Platform Platform
//
// A platform upon which a build can be built.
// swagger:model V1RecipeResponseRecipesItems0Platform
type V1RecipeResponseRecipesItems0Platform struct {

	// CPU Architecture
	//
	// The full CPU architecture data model
	// Required: true
	CPUArchitecture struct {

		// cpu architecture id
		// Required: true
		// Format: uuid
		CPUArchitectureID *strfmt.UUID `json:"cpu_architecture_id"`

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAO0Links `json:"links"`

		V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"cpu_architecture"`

	// cpu extensions
	CPUExtensions []*V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0 `json:"cpu_extensions"`

	// The date and time this platform was created.
	// Required: true
	// Format: date-time
	CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

	// display name
	// Required: true
	DisplayName *string `json:"display_name"`

	// The last day on which this platform will be supported. Can be omitted if no last day has yet been determined.
	// Format: date
	EndOfSupportDate *strfmt.Date `json:"end_of_support_date,omitempty"`

	// GPU Architecture
	//
	// The full GPU architecture data model
	GpuArchitecture struct {

		// gpu architecture id
		// Required: true
		// Format: uuid
		GpuArchitectureID *strfmt.UUID `json:"gpu_architecture_id"`

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAO0Links `json:"links"`

		V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"gpu_architecture,omitempty"`

	// images
	// Required: true
	Images []*V1RecipeResponseRecipesItems0PlatformImagesItems0 `json:"images"`

	// If true, the platform should be shown to the user as a selectable platform for an order. If false, the platform should be hidden from the user.
	IsUserVisible *bool `json:"is_user_visible,omitempty"`

	// Kernel
	//
	// The full kernel data model
	// Required: true
	Kernel struct {

		// kernel id
		// Required: true
		// Format: uuid
		KernelID *strfmt.UUID `json:"kernel_id"`

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0PlatformKernelAO0Links `json:"links"`

		// The name of the kernel (excluding any version information)
		// Required: true
		Name *string `json:"name"`
	} `json:"kernel"`

	// Kernel Version
	//
	// The full kernel version data model
	// Required: true
	KernelVersion struct {

		// kernel version id
		// Required: true
		// Format: uuid
		KernelVersionID *strfmt.UUID `json:"kernel_version_id"`

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0PlatformKernelVersionAO0Links `json:"links"`

		V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"kernel_version"`

	// Libc
	//
	// The full libc data model
	Libc struct {

		// libc id
		// Required: true
		// Format: uuid
		LibcID *strfmt.UUID `json:"libc_id"`

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0PlatformLibcAO0Links `json:"links"`

		// The name of the libc (excluding any version information)
		// Required: true
		Name *string `json:"name"`
	} `json:"libc,omitempty"`

	// Libc Version
	//
	// The full libc version data model
	LibcVersion struct {

		// libc version id
		// Required: true
		// Format: uuid
		LibcVersionID *strfmt.UUID `json:"libc_version_id"`

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0PlatformLibcVersionAO0Links `json:"links"`

		V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"libc_version,omitempty"`

	// links
	// Required: true
	Links *V1RecipeResponseRecipesItems0PlatformLinks `json:"links"`

	// Operating System
	//
	// The full operating system data model
	// Required: true
	OperatingSystem struct {

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0PlatformOperatingSystemAO0Links `json:"links"`

		// operating system id
		// Required: true
		// Format: uuid
		OperatingSystemID *strfmt.UUID `json:"operating_system_id"`

		// Whether an implementation of libc is considered a core feature of the OS. This is generally true for *nix OSes and false for others.
		// Required: true
		HasLibc *bool `json:"has_libc"`

		// The name of the operating system (excluding any version information). This should be more specific than just an OS class (e.g. 'Red Star OS' rather than just 'Linux')
		// Required: true
		Name *string `json:"name"`
	} `json:"operating_system"`

	// Operating System Version
	//
	// The full operating system version data model
	// Required: true
	OperatingSystemVersion struct {

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAO0Links `json:"links"`

		// operating system version id
		// Required: true
		// Format: uuid
		OperatingSystemVersionID *strfmt.UUID `json:"operating_system_version_id"`

		V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	} `json:"operating_system_version"`

	// platform id
	// Required: true
	// Format: uuid
	PlatformID *strfmt.UUID `json:"platform_id"`
}

// Validate validates this v1 recipe response recipes items0 platform
func (m *V1RecipeResponseRecipesItems0Platform) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPUArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCPUExtensions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndOfSupportDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKernel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKernelVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLibc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLibcVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperatingSystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperatingSystemVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateCPUArchitecture(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"cpu_architecture"+"."+"cpu_architecture_id", "body", m.CPUArchitecture.CPUArchitectureID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"cpu_architecture"+"."+"cpu_architecture_id", "body", "uuid", m.CPUArchitecture.CPUArchitectureID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"cpu_architecture"+"."+"links", "body", m.CPUArchitecture.Links); err != nil {
		return err
	}

	if m.CPUArchitecture.Links != nil {
		if err := m.CPUArchitecture.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform" + "." + "cpu_architecture" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("platform"+"."+"cpu_architecture"+"."+"revision", "body", m.CPUArchitecture.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("platform"+"."+"cpu_architecture"+"."+"revision", "body", int64(*m.CPUArchitecture.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"cpu_architecture"+"."+"revision_timestamp", "body", m.CPUArchitecture.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"cpu_architecture"+"."+"revision_timestamp", "body", "date-time", m.CPUArchitecture.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateCPUExtensions(formats strfmt.Registry) error {

	if swag.IsZero(m.CPUExtensions) { // not required
		return nil
	}

	for i := 0; i < len(m.CPUExtensions); i++ {
		if swag.IsZero(m.CPUExtensions[i]) { // not required
			continue
		}

		if m.CPUExtensions[i] != nil {
			if err := m.CPUExtensions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("platform" + "." + "cpu_extensions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateCreationTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"creation_timestamp", "body", m.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"creation_timestamp", "body", "date-time", m.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateDisplayName(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"display_name", "body", m.DisplayName); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateEndOfSupportDate(formats strfmt.Registry) error {

	if swag.IsZero(m.EndOfSupportDate) { // not required
		return nil
	}

	if err := validate.FormatOf("platform"+"."+"end_of_support_date", "body", "date", m.EndOfSupportDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateGpuArchitecture(formats strfmt.Registry) error {

	if swag.IsZero(m.GpuArchitecture) { // not required
		return nil
	}

	if err := validate.Required("platform"+"."+"gpu_architecture"+"."+"gpu_architecture_id", "body", m.GpuArchitecture.GpuArchitectureID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"gpu_architecture"+"."+"gpu_architecture_id", "body", "uuid", m.GpuArchitecture.GpuArchitectureID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"gpu_architecture"+"."+"links", "body", m.GpuArchitecture.Links); err != nil {
		return err
	}

	if m.GpuArchitecture.Links != nil {
		if err := m.GpuArchitecture.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform" + "." + "gpu_architecture" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("platform"+"."+"gpu_architecture"+"."+"revision", "body", m.GpuArchitecture.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("platform"+"."+"gpu_architecture"+"."+"revision", "body", int64(*m.GpuArchitecture.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"gpu_architecture"+"."+"revision_timestamp", "body", m.GpuArchitecture.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"gpu_architecture"+"."+"revision_timestamp", "body", "date-time", m.GpuArchitecture.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateImages(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"images", "body", m.Images); err != nil {
		return err
	}

	for i := 0; i < len(m.Images); i++ {
		if swag.IsZero(m.Images[i]) { // not required
			continue
		}

		if m.Images[i] != nil {
			if err := m.Images[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("platform" + "." + "images" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateKernel(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"kernel"+"."+"kernel_id", "body", m.Kernel.KernelID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"kernel"+"."+"kernel_id", "body", "uuid", m.Kernel.KernelID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"kernel"+"."+"links", "body", m.Kernel.Links); err != nil {
		return err
	}

	if m.Kernel.Links != nil {
		if err := m.Kernel.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform" + "." + "kernel" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("platform"+"."+"kernel"+"."+"name", "body", m.Kernel.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateKernelVersion(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"kernel_version"+"."+"kernel_version_id", "body", m.KernelVersion.KernelVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"kernel_version"+"."+"kernel_version_id", "body", "uuid", m.KernelVersion.KernelVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"kernel_version"+"."+"links", "body", m.KernelVersion.Links); err != nil {
		return err
	}

	if m.KernelVersion.Links != nil {
		if err := m.KernelVersion.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform" + "." + "kernel_version" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("platform"+"."+"kernel_version"+"."+"revision", "body", m.KernelVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("platform"+"."+"kernel_version"+"."+"revision", "body", int64(*m.KernelVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"kernel_version"+"."+"revision_timestamp", "body", m.KernelVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"kernel_version"+"."+"revision_timestamp", "body", "date-time", m.KernelVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateLibc(formats strfmt.Registry) error {

	if swag.IsZero(m.Libc) { // not required
		return nil
	}

	if err := validate.Required("platform"+"."+"libc"+"."+"libc_id", "body", m.Libc.LibcID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"libc"+"."+"libc_id", "body", "uuid", m.Libc.LibcID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"libc"+"."+"links", "body", m.Libc.Links); err != nil {
		return err
	}

	if m.Libc.Links != nil {
		if err := m.Libc.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform" + "." + "libc" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("platform"+"."+"libc"+"."+"name", "body", m.Libc.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateLibcVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.LibcVersion) { // not required
		return nil
	}

	if err := validate.Required("platform"+"."+"libc_version"+"."+"libc_version_id", "body", m.LibcVersion.LibcVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"libc_version"+"."+"libc_version_id", "body", "uuid", m.LibcVersion.LibcVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"libc_version"+"."+"links", "body", m.LibcVersion.Links); err != nil {
		return err
	}

	if m.LibcVersion.Links != nil {
		if err := m.LibcVersion.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform" + "." + "libc_version" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("platform"+"."+"libc_version"+"."+"revision", "body", m.LibcVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("platform"+"."+"libc_version"+"."+"revision", "body", int64(*m.LibcVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"libc_version"+"."+"revision_timestamp", "body", m.LibcVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"libc_version"+"."+"revision_timestamp", "body", "date-time", m.LibcVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform" + "." + "links")
			}
			return err
		}
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateOperatingSystem(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"operating_system"+"."+"links", "body", m.OperatingSystem.Links); err != nil {
		return err
	}

	if m.OperatingSystem.Links != nil {
		if err := m.OperatingSystem.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform" + "." + "operating_system" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("platform"+"."+"operating_system"+"."+"operating_system_id", "body", m.OperatingSystem.OperatingSystemID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"operating_system"+"."+"operating_system_id", "body", "uuid", m.OperatingSystem.OperatingSystemID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"operating_system"+"."+"has_libc", "body", m.OperatingSystem.HasLibc); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"operating_system"+"."+"name", "body", m.OperatingSystem.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validateOperatingSystemVersion(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"operating_system_version"+"."+"links", "body", m.OperatingSystemVersion.Links); err != nil {
		return err
	}

	if m.OperatingSystemVersion.Links != nil {
		if err := m.OperatingSystemVersion.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("platform" + "." + "operating_system_version" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("platform"+"."+"operating_system_version"+"."+"operating_system_version_id", "body", m.OperatingSystemVersion.OperatingSystemVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"operating_system_version"+"."+"operating_system_version_id", "body", "uuid", m.OperatingSystemVersion.OperatingSystemVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"operating_system_version"+"."+"revision", "body", m.OperatingSystemVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("platform"+"."+"operating_system_version"+"."+"revision", "body", int64(*m.OperatingSystemVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("platform"+"."+"operating_system_version"+"."+"revision_timestamp", "body", m.OperatingSystemVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"operating_system_version"+"."+"revision_timestamp", "body", "date-time", m.OperatingSystemVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0Platform) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"platform_id", "body", "uuid", m.PlatformID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0Platform) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0Platform) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0Platform
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformCPUArchitectureAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformCPUArchitectureAO0Links
type V1RecipeResponseRecipesItems0PlatformCPUArchitectureAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform CPU architecture a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"cpu_architecture"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"cpu_architecture"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformCPUArchitectureAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1 CPU Architecture Core
//
// The properties of a CPU architecture needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1
type V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1 struct {

	// bit width
	// Enum: [32 64]
	BitWidth string `json:"bit_width,omitempty"`

	// The name of the CPU architecture
	// Required: true
	Name *string `json:"name"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		BitWidth string `json:"bit_width,omitempty"`

		Name *string `json:"name"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.BitWidth = dataAO0.BitWidth

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		BitWidth string `json:"bit_width,omitempty"`

		Name *string `json:"name"`
	}

	dataAO0.BitWidth = m.BitWidth

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform CPU architecture all of1
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBitWidth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1RecipeResponseRecipesItems0PlatformCpuArchitectureAllOf1TypeBitWidthPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["32","64"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0PlatformCpuArchitectureAllOf1TypeBitWidthPropEnum = append(v1RecipeResponseRecipesItems0PlatformCpuArchitectureAllOf1TypeBitWidthPropEnum, v)
	}
}

// property enum
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1) validateBitWidthEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0PlatformCpuArchitectureAllOf1TypeBitWidthPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1) validateBitWidth(formats strfmt.Registry) error {

	if swag.IsZero(m.BitWidth) { // not required
		return nil
	}

	// value enum
	if err := m.validateBitWidthEnum("bit_width", "body", m.BitWidth); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0
type V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform CPU architecture all of1 provided features items0
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformCPUArchitectureAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0 CPU Extension
//
// The full CPU extension data model
// swagger:model V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0
type V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0 struct {

	// cpu extension id
	// Required: true
	// Format: uuid
	CPUExtensionID *strfmt.UUID `json:"cpu_extension_id"`

	// links
	// Required: true
	Links *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links `json:"links"`

	V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1

	// The revision number of this revision of the resource. This number increases monotonically with each new revision.
	// Required: true
	// Minimum: 1
	Revision *int64 `json:"revision"`

	// The date and time at which this revision of the resource was created
	// Required: true
	// Format: date-time
	RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CPUExtensionID *strfmt.UUID `json:"cpu_extension_id"`

		Links *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links `json:"links"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CPUExtensionID = dataAO0.CPUExtensionID

	m.Links = dataAO0.Links

	// AO1
	var aO1 V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1 = aO1

	// AO2
	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Revision = dataAO2.Revision

	m.RevisionTimestamp = dataAO2.RevisionTimestamp

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		CPUExtensionID *strfmt.UUID `json:"cpu_extension_id"`

		Links *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links `json:"links"`
	}

	dataAO0.CPUExtensionID = m.CPUExtensionID

	dataAO0.Links = m.Links

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}

	dataAO2.Revision = m.Revision

	dataAO2.RevisionTimestamp = m.RevisionTimestamp

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform CPU extensions items0
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPUExtensionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1
	if err := m.V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevisionTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0) validateCPUExtensionID(formats strfmt.Registry) error {

	if err := validate.Required("cpu_extension_id", "body", m.CPUExtensionID); err != nil {
		return err
	}

	if err := validate.FormatOf("cpu_extension_id", "body", "uuid", m.CPUExtensionID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0) validateRevision(formats strfmt.Registry) error {

	if err := validate.Required("revision", "body", m.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("revision", "body", int64(*m.Revision), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0) validateRevisionTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("revision_timestamp", "body", m.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("revision_timestamp", "body", "date-time", m.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links
type V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform CPU extensions items0 a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1 CPU Extension Core
//
// The properties of a CPU extension needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1
type V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1 struct {

	// The name of the CPU extension
	// Required: true
	Name *string `json:"name"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`
	}

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform CPU extensions items0 all of1
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0
type V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform CPU extensions items0 all of1 provided features items0
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformCPUExtensionsItems0AllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformGpuArchitectureAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformGpuArchitectureAO0Links
type V1RecipeResponseRecipesItems0PlatformGpuArchitectureAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform gpu architecture a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"gpu_architecture"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"gpu_architecture"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformGpuArchitectureAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1 GPU Architecture Core
//
// The properties of a GPU architecture needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1
type V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1 struct {

	// The name of the GPU architecture
	// Required: true
	Name *string `json:"name"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`
	}

	dataAO0.Name = m.Name

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform gpu architecture all of1
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0
type V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform gpu architecture all of1 provided features items0
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformGpuArchitectureAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformImagesItems0 Image
//
// The full image data model
// swagger:model V1RecipeResponseRecipesItems0PlatformImagesItems0
type V1RecipeResponseRecipesItems0PlatformImagesItems0 struct {

	// image id
	// Required: true
	// Format: uuid
	ImageID *strfmt.UUID `json:"image_id"`

	// links
	// Required: true
	Links *V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links `json:"links"`

	V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1

	// The revision number of this revision of the resource. This number increases monotonically with each new revision.
	// Required: true
	// Minimum: 1
	Revision *int64 `json:"revision"`

	// The date and time at which this revision of the resource was created
	// Required: true
	// Format: date-time
	RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		ImageID *strfmt.UUID `json:"image_id"`

		Links *V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links `json:"links"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.ImageID = dataAO0.ImageID

	m.Links = dataAO0.Links

	// AO1
	var aO1 V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1 = aO1

	// AO2
	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Revision = dataAO2.Revision

	m.RevisionTimestamp = dataAO2.RevisionTimestamp

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformImagesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		ImageID *strfmt.UUID `json:"image_id"`

		Links *V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links `json:"links"`
	}

	dataAO0.ImageID = m.ImageID

	dataAO0.Links = m.Links

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	var dataAO2 struct {
		Revision *int64 `json:"revision"`

		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`
	}

	dataAO2.Revision = m.Revision

	dataAO2.RevisionTimestamp = m.RevisionTimestamp

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform images items0
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateImageID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1
	if err := m.V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevisionTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0) validateImageID(formats strfmt.Registry) error {

	if err := validate.Required("image_id", "body", m.ImageID); err != nil {
		return err
	}

	if err := validate.FormatOf("image_id", "body", "uuid", m.ImageID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0) validateRevision(formats strfmt.Registry) error {

	if err := validate.Required("revision", "body", m.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("revision", "body", int64(*m.Revision), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0) validateRevisionTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("revision_timestamp", "body", m.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("revision_timestamp", "body", "date-time", m.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformImagesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links
type V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform images items0 a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformImagesItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1 Image Core
//
// The properties of an image needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1
type V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1 struct {

	// The name of the image (excluding any version information). This will be something like "activestate/centos-6.9-build" (for a Docker image) or "ami-foo-12345" (WindowsInstance).
	// Required: true
	Name *string `json:"name"`

	// The platform to which this image belongs.
	// Required: true
	PlatformID *string `json:"platform_id"`

	// The type of the image.
	// Required: true
	// Enum: [Docker WindowsInstance]
	Type *string `json:"type"`

	V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Name = dataAO0.Name

	m.PlatformID = dataAO0.PlatformID

	m.Type = dataAO0.Type

	// AO1
	var aO1 V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1 = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Name *string `json:"name"`

		PlatformID *string `json:"platform_id"`

		Type *string `json:"type"`
	}

	dataAO0.Name = m.Name

	dataAO0.PlatformID = m.PlatformID

	dataAO0.Type = m.Type

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform images items0 all of1
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1
	if err := m.V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1) validatePlatformID(formats strfmt.Registry) error {

	if err := validate.Required("platform_id", "body", m.PlatformID); err != nil {
		return err
	}

	return nil
}

var v1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Docker","WindowsInstance"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1TypeTypePropEnum = append(v1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1TypeTypePropEnum, v)
	}
}

// property enum
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1TypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1 Image Revision Core
//
// The properties of an image revision needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1
type V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`

	// conditions
	Conditions []*V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0 `json:"conditions"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	// AO2
	var dataAO2 struct {
		Conditions []*V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO2); err != nil {
		return err
	}

	m.Conditions = dataAO2.Conditions

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 3)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	var dataAO2 struct {
		Conditions []*V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0 `json:"conditions,omitempty"`
	}

	dataAO2.Conditions = m.Conditions

	jsonDataAO2, errAO2 := swag.WriteJSON(dataAO2)
	if errAO2 != nil {
		return nil, errAO2
	}
	_parts = append(_parts, jsonDataAO2)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform images items0 all of1 all of1
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0
type V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 recipe response recipes items0 platform images items0 all of1 all of1 conditions items0
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0 v1 recipe response recipes items0 platform images items0 all of1 all of1 conditions items0 requirements items0
// swagger:model V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0
type V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 recipe response recipes items0 platform images items0 all of1 all of1 conditions items0 requirements items0
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0
type V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform images items0 all of1 all of1 provided features items0
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformImagesItems0AllOf1AllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformKernelAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformKernelAO0Links
type V1RecipeResponseRecipesItems0PlatformKernelAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform kernel a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformKernelAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"kernel"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"kernel"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformKernelAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformKernelAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformKernelAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformKernelVersionAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformKernelVersionAO0Links
type V1RecipeResponseRecipesItems0PlatformKernelVersionAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform kernel version a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"kernel_version"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"kernel_version"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformKernelVersionAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1 Kernel Version Core
//
// The properties of a kernel version needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1
type V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform kernel version all of1
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0
type V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform kernel version all of1 provided features items0
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformKernelVersionAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformLibcAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformLibcAO0Links
type V1RecipeResponseRecipesItems0PlatformLibcAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform libc a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformLibcAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"libc"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"libc"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLibcAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLibcAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformLibcAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformLibcVersionAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformLibcVersionAO0Links
type V1RecipeResponseRecipesItems0PlatformLibcVersionAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform libc version a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"libc_version"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"libc_version"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformLibcVersionAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1 Libc Version Core
//
// The properties of a libc version needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1
type V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform libc version all of1
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0
type V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform libc version all of1 provided features items0
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformLibcVersionAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformLinks Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformLinks
type V1RecipeResponseRecipesItems0PlatformLinks struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform links
func (m *V1RecipeResponseRecipesItems0PlatformLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformLinks) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformLinks) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformOperatingSystemAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformOperatingSystemAO0Links
type V1RecipeResponseRecipesItems0PlatformOperatingSystemAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform operating system a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"operating_system"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"operating_system"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformOperatingSystemAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAO0Links
type V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 platform operating system version a o0 links
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("platform"+"."+"operating_system_version"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("platform"+"."+"operating_system_version"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1 Operating System Version Core
//
// The properties of an operating system version needed to create a new one
// swagger:model V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1
type V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1 struct {

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.SortableVersion = dataAO0.SortableVersion

	m.Version = dataAO0.Version

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO0.SortableVersion = m.SortableVersion

	dataAO0.Version = m.Version

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform operating system version all of1
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0
type V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 platform operating system version all of1 provided features items0
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0PlatformOperatingSystemVersionAllOf1ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0 Resolved Ingredient
//
// An ingredient that is part of a recipe's resolved requirements
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0 struct {

	// Alternative ingredient versions which can also satisfy the order's requirement. Each entry in the array is the ID of an ingredient version which could satisfy these requirements.
	Alternatives []strfmt.UUID `json:"alternatives"`

	// The custom build scripts for building this ingredient, if any
	BuildScripts []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0 `json:"build_scripts"`

	// This dependencies in the recipe for this ingredient version. Each item contains an ingredient version UUID which maps to an ingredient version in this recipe.
	Dependencies []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0 `json:"dependencies"`

	// Ingredient
	//
	// A unique ingredient that can be used in a recipe. This model contains all ingredient properties and is returned from read requests.
	// Required: true
	Ingredient struct {

		// creation timestamp
		// Required: true
		// Format: date-time
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		// ingredient id
		// Required: true
		// Format: uuid
		IngredientID *strfmt.UUID `json:"ingredient_id"`

		// links
		// Required: true
		Links *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientAO0Links `json:"links"`

		// A concise summary of what this ingredient can be used for
		// Required: true
		Description *string `json:"description"`

		// The name of the ingredient (excluding any version information)
		// Required: true
		Name *string `json:"name"`

		// The UUID of the organization the ingredient belongs to, if it is private to a particular organization
		// Required: true
		// Format: uuid
		OrganizationID *strfmt.UUID `json:"organization_id"`

		// The primary namespace to which this ingredient belongs
		// Required: true
		PrimaryNamespace *string `json:"primary_namespace"`

		// URL of the website about this ingredient (if any)
		// Required: true
		// Format: uri
		Website *strfmt.URI `json:"website"`
	} `json:"ingredient"`

	// Ingredient Version
	//
	// The full ingredient version data model. Returned from all read requests.
	// Required: true
	IngredientVersion struct {

		// creation timestamp
		// Required: true
		// Format: date-time
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		// ingredient id
		// Required: true
		// Format: uuid
		IngredientID *strfmt.UUID `json:"ingredient_id"`

		// ingredient version id
		// Required: true
		// Format: uuid
		IngredientVersionID *strfmt.UUID `json:"ingredient_version_id"`

		// links
		// Required: true
		Links struct {

			// The URI of this resource
			// Required: true
			// Format: uri
			Self *strfmt.URI `json:"self"`

			// The URI of the ingredient this is a version of
			// Required: true
			// Format: uri
			Ingredient *strfmt.URI `json:"ingredient"`
		} `json:"links"`

		// The revision number of this revision of the resource. This number increases monotonically with each new revision.
		// Required: true
		// Minimum: 1
		Revision *int64 `json:"revision"`

		// The date and time at which this revision of the resource was created
		// Required: true
		// Format: date-time
		RevisionTimestamp *strfmt.DateTime `json:"revision_timestamp"`

		V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2

		V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3
	} `json:"ingredient_version"`

	// The patches to apply to this ingredient's source before building, if any
	Patches []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0 `json:"patches"`

	// The original requirement(s) in the order that were resolved to this ingredient version. This list will be empty if an ingredient was added to the recipe to fulfill a dependency of something else in the order.
	ResolvedRequirements []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0 `json:"resolved_requirements"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlternatives(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuildScripts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredient(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePatches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolvedRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) validateAlternatives(formats strfmt.Registry) error {

	if swag.IsZero(m.Alternatives) { // not required
		return nil
	}

	for i := 0; i < len(m.Alternatives); i++ {

		if err := validate.FormatOf("alternatives"+"."+strconv.Itoa(i), "body", "uuid", m.Alternatives[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) validateBuildScripts(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildScripts) { // not required
		return nil
	}

	for i := 0; i < len(m.BuildScripts); i++ {
		if swag.IsZero(m.BuildScripts[i]) { // not required
			continue
		}

		if m.BuildScripts[i] != nil {
			if err := m.BuildScripts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("build_scripts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) validateDependencies(formats strfmt.Registry) error {

	if swag.IsZero(m.Dependencies) { // not required
		return nil
	}

	for i := 0; i < len(m.Dependencies); i++ {
		if swag.IsZero(m.Dependencies[i]) { // not required
			continue
		}

		if m.Dependencies[i] != nil {
			if err := m.Dependencies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependencies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) validateIngredient(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"creation_timestamp", "body", m.Ingredient.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"creation_timestamp", "body", "date-time", m.Ingredient.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"ingredient_id", "body", m.Ingredient.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"ingredient_id", "body", "uuid", m.Ingredient.IngredientID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"links", "body", m.Ingredient.Links); err != nil {
		return err
	}

	if m.Ingredient.Links != nil {
		if err := m.Ingredient.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ingredient" + "." + "links")
			}
			return err
		}
	}

	if err := validate.Required("ingredient"+"."+"description", "body", m.Ingredient.Description); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"name", "body", m.Ingredient.Name); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"organization_id", "body", m.Ingredient.OrganizationID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"organization_id", "body", "uuid", m.Ingredient.OrganizationID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"primary_namespace", "body", m.Ingredient.PrimaryNamespace); err != nil {
		return err
	}

	if err := validate.Required("ingredient"+"."+"website", "body", m.Ingredient.Website); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"website", "body", "uri", m.Ingredient.Website.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) validateIngredientVersion(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version"+"."+"creation_timestamp", "body", m.IngredientVersion.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"creation_timestamp", "body", "date-time", m.IngredientVersion.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"ingredient_id", "body", m.IngredientVersion.IngredientID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"ingredient_id", "body", "uuid", m.IngredientVersion.IngredientID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"ingredient_version_id", "body", m.IngredientVersion.IngredientVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"ingredient_version_id", "body", "uuid", m.IngredientVersion.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"links"+"."+"self", "body", m.IngredientVersion.Links.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"links"+"."+"self", "body", "uri", m.IngredientVersion.Links.Self.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"links"+"."+"ingredient", "body", m.IngredientVersion.Links.Ingredient); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"links"+"."+"ingredient", "body", "uri", m.IngredientVersion.Links.Ingredient.String(), formats); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"revision", "body", m.IngredientVersion.Revision); err != nil {
		return err
	}

	if err := validate.MinimumInt("ingredient_version"+"."+"revision", "body", int64(*m.IngredientVersion.Revision), 1, false); err != nil {
		return err
	}

	if err := validate.Required("ingredient_version"+"."+"revision_timestamp", "body", m.IngredientVersion.RevisionTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version"+"."+"revision_timestamp", "body", "date-time", m.IngredientVersion.RevisionTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) validatePatches(formats strfmt.Registry) error {

	if swag.IsZero(m.Patches) { // not required
		return nil
	}

	for i := 0; i < len(m.Patches); i++ {
		if swag.IsZero(m.Patches[i]) { // not required
			continue
		}

		if m.Patches[i] != nil {
			if err := m.Patches[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) validateResolvedRequirements(formats strfmt.Registry) error {

	if swag.IsZero(m.ResolvedRequirements) { // not required
		return nil
	}

	for i := 0; i < len(m.ResolvedRequirements); i++ {
		if swag.IsZero(m.ResolvedRequirements[i]) { // not required
			continue
		}

		if m.ResolvedRequirements[i] != nil {
			if err := m.ResolvedRequirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resolved_requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0 Build Script
//
// A short piece of scripting code that can be used to build an ingredient. This model contains all build script properties and is returned from read requests
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0 struct {

	// build script id
	// Required: true
	// Format: uuid
	BuildScriptID *strfmt.UUID `json:"build_script_id"`

	// creation timestamp
	// Required: true
	// Format: date-time
	CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

	// links
	// Required: true
	Links *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links `json:"links"`

	// The features that must already be present in the recipe for this build script to be used. For example, can be used to create build scripts that only work on specific operating systems.
	Conditions []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 `json:"conditions"`

	// The scripting language that the build script is written in
	// Required: true
	// Enum: [bash perl python]
	Language *string `json:"language"`

	// The build script itself
	// Required: true
	Script *string `json:"script"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		BuildScriptID *strfmt.UUID `json:"build_script_id"`

		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links `json:"links"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.BuildScriptID = dataAO0.BuildScriptID

	m.CreationTimestamp = dataAO0.CreationTimestamp

	m.Links = dataAO0.Links

	// AO1
	var dataAO1 struct {
		Conditions []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 `json:"conditions,omitempty"`

		Language *string `json:"language"`

		Script *string `json:"script"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Conditions = dataAO1.Conditions

	m.Language = dataAO1.Language

	m.Script = dataAO1.Script

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		BuildScriptID *strfmt.UUID `json:"build_script_id"`

		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links `json:"links"`
	}

	dataAO0.BuildScriptID = m.BuildScriptID

	dataAO0.CreationTimestamp = m.CreationTimestamp

	dataAO0.Links = m.Links

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		Conditions []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 `json:"conditions,omitempty"`

		Language *string `json:"language"`

		Script *string `json:"script"`
	}

	dataAO1.Conditions = m.Conditions

	dataAO1.Language = m.Language

	dataAO1.Script = m.Script

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 build scripts items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildScriptID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScript(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) validateBuildScriptID(formats strfmt.Registry) error {

	if err := validate.Required("build_script_id", "body", m.BuildScriptID); err != nil {
		return err
	}

	if err := validate.FormatOf("build_script_id", "body", "uuid", m.BuildScriptID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) validateCreationTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("creation_timestamp", "body", m.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("creation_timestamp", "body", "date-time", m.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var v1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0TypeLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bash","perl","python"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0TypeLanguagePropEnum = append(v1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0TypeLanguagePropEnum, v)
	}
}

// property enum
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) validateLanguageEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0TypeLanguagePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) validateLanguage(formats strfmt.Registry) error {

	if err := validate.Required("language", "body", m.Language); err != nil {
		return err
	}

	// value enum
	if err := m.validateLanguageEnum("language", "body", *m.Language); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) validateScript(formats strfmt.Registry) error {

	if err := validate.Required("script", "body", m.Script); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 build scripts items0 a o0 links
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 build scripts items0 conditions items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0 v1 recipe response recipes items0 resolved ingredients items0 build scripts items0 conditions items0 requirements items0
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 build scripts items0 conditions items0 requirements items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0BuildScriptsItems0ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0 v1 recipe response recipes items0 resolved ingredients items0 dependencies items0
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0 struct {

	// The type or types of dependencies on this ingredient version.
	// Required: true
	// Min Items: 1
	// Unique: true
	DependencyTypes []string `json:"dependency_types"`

	// ingredient version id
	// Required: true
	// Format: uuid
	IngredientVersionID *strfmt.UUID `json:"ingredient_version_id"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 dependencies items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencyTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0DependencyTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build","runtime","test"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0DependencyTypesItemsEnum = append(v1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0DependencyTypesItemsEnum, v)
	}
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0) validateDependencyTypesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0DependencyTypesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0) validateDependencyTypes(formats strfmt.Registry) error {

	if err := validate.Required("dependency_types", "body", m.DependencyTypes); err != nil {
		return err
	}

	iDependencyTypesSize := int64(len(m.DependencyTypes))

	if err := validate.MinItems("dependency_types", "body", iDependencyTypesSize, 1); err != nil {
		return err
	}

	if err := validate.UniqueItems("dependency_types", "body", m.DependencyTypes); err != nil {
		return err
	}

	for i := 0; i < len(m.DependencyTypes); i++ {

		// value enum
		if err := m.validateDependencyTypesItemsEnum("dependency_types"+"."+strconv.Itoa(i), "body", m.DependencyTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0) validateIngredientVersionID(formats strfmt.Registry) error {

	if err := validate.Required("ingredient_version_id", "body", m.IngredientVersionID); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient_version_id", "body", "uuid", m.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0DependenciesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientAO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientAO0Links
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientAO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 ingredient a o0 links
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientAO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientAO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("ingredient"+"."+"links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("ingredient"+"."+"links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientAO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientAO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientAO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2 Ingredient Version Core
//
// The fields of an ingredient version that can be set when an ingredient version is created
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2 struct {

	// The text from the license or elsewhere that declares the copyright holder(s) and year(s)
	// Required: true
	CopyrightText *string `json:"copyright_text"`

	// The URL of a webpage where the documentation for this ingredient version is hosted, if available
	// Format: uri
	DocumentationURI strfmt.URI `json:"documentation_uri,omitempty"`

	// Tells if this ingredient version consists of only a binary without any source.
	IsBinaryOnly *bool `json:"is_binary_only,omitempty"`

	// An SPDX 2.1 license expression describing the exact licensing for this ingredient version
	// Required: true
	LicenseExpression *string `json:"license_expression"`

	// The date and time this ingredient version was first released
	// Required: true
	// Format: date-time
	ReleaseTimestamp *strfmt.DateTime `json:"release_timestamp"`

	// The URL from which we initially retrieved the source for this ingredient version.
	// Format: uri
	SourceURI *strfmt.URI `json:"source_uri,omitempty"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CopyrightText *string `json:"copyright_text"`

		DocumentationURI strfmt.URI `json:"documentation_uri,omitempty"`

		IsBinaryOnly *bool `json:"is_binary_only,omitempty"`

		LicenseExpression *string `json:"license_expression"`

		ReleaseTimestamp *strfmt.DateTime `json:"release_timestamp"`

		SourceURI *strfmt.URI `json:"source_uri,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CopyrightText = dataAO0.CopyrightText

	m.DocumentationURI = dataAO0.DocumentationURI

	m.IsBinaryOnly = dataAO0.IsBinaryOnly

	m.LicenseExpression = dataAO0.LicenseExpression

	m.ReleaseTimestamp = dataAO0.ReleaseTimestamp

	m.SourceURI = dataAO0.SourceURI

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		CopyrightText *string `json:"copyright_text"`

		DocumentationURI strfmt.URI `json:"documentation_uri,omitempty"`

		IsBinaryOnly *bool `json:"is_binary_only,omitempty"`

		LicenseExpression *string `json:"license_expression"`

		ReleaseTimestamp *strfmt.DateTime `json:"release_timestamp"`

		SourceURI *strfmt.URI `json:"source_uri,omitempty"`
	}

	dataAO0.CopyrightText = m.CopyrightText

	dataAO0.DocumentationURI = m.DocumentationURI

	dataAO0.IsBinaryOnly = m.IsBinaryOnly

	dataAO0.LicenseExpression = m.LicenseExpression

	dataAO0.ReleaseTimestamp = m.ReleaseTimestamp

	dataAO0.SourceURI = m.SourceURI

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of2
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCopyrightText(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocumentationURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicenseExpression(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReleaseTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) validateCopyrightText(formats strfmt.Registry) error {

	if err := validate.Required("copyright_text", "body", m.CopyrightText); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) validateDocumentationURI(formats strfmt.Registry) error {

	if swag.IsZero(m.DocumentationURI) { // not required
		return nil
	}

	if err := validate.FormatOf("documentation_uri", "body", "uri", m.DocumentationURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) validateLicenseExpression(formats strfmt.Registry) error {

	if err := validate.Required("license_expression", "body", m.LicenseExpression); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) validateReleaseTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("release_timestamp", "body", m.ReleaseTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("release_timestamp", "body", "date-time", m.ReleaseTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) validateSourceURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceURI) { // not required
		return nil
	}

	if err := validate.FormatOf("source_uri", "body", "uri", m.SourceURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf2
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3 Ingredient Version Revision Core
//
// The fields of an ingredient version that can be updated by creating a new revision
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3 struct {

	// Camel-specific metadata needed to build this ingredient version revision in camel, if there is any.
	CamelExtras interface{} `json:"camel_extras,omitempty"`

	// dependency sets
	DependencySets []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 `json:"dependency_sets"`

	// Whether or not this is a stable release of the package
	IsStableRelease *bool `json:"is_stable_release,omitempty"`

	// S3 URL where the source distribution is stored for our platform
	// Format: uri
	PlatformSourceURI *strfmt.URI `json:"platform_source_uri,omitempty"`

	// A checksum of the source distribution. The actual type of the checksum (MD5, S3 Etag, etc.) is not specified. It's assumed that the system that populates and uses this data will know how to work with these checksums.
	SourceChecksum *string `json:"source_checksum,omitempty"`

	// Whether this revision should be considered 'stable'. When a new stable revision is created, it supercedes any existing stable revision and becomes the default revision of the revisioned resource going forward.
	IsStableRevision *bool `json:"is_stable_revision,omitempty"`

	// provided features
	// Required: true
	ProvidedFeatures []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 `json:"provided_features"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CamelExtras interface{} `json:"camel_extras,omitempty"`

		DependencySets []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 `json:"dependency_sets,omitempty"`

		IsStableRelease *bool `json:"is_stable_release,omitempty"`

		PlatformSourceURI *strfmt.URI `json:"platform_source_uri,omitempty"`

		SourceChecksum *string `json:"source_checksum,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CamelExtras = dataAO0.CamelExtras

	m.DependencySets = dataAO0.DependencySets

	m.IsStableRelease = dataAO0.IsStableRelease

	m.PlatformSourceURI = dataAO0.PlatformSourceURI

	m.SourceChecksum = dataAO0.SourceChecksum

	// AO1
	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 `json:"provided_features"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.IsStableRevision = dataAO1.IsStableRevision

	m.ProvidedFeatures = dataAO1.ProvidedFeatures

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		CamelExtras interface{} `json:"camel_extras,omitempty"`

		DependencySets []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 `json:"dependency_sets,omitempty"`

		IsStableRelease *bool `json:"is_stable_release,omitempty"`

		PlatformSourceURI *strfmt.URI `json:"platform_source_uri,omitempty"`

		SourceChecksum *string `json:"source_checksum,omitempty"`
	}

	dataAO0.CamelExtras = m.CamelExtras

	dataAO0.DependencySets = m.DependencySets

	dataAO0.IsStableRelease = m.IsStableRelease

	dataAO0.PlatformSourceURI = m.PlatformSourceURI

	dataAO0.SourceChecksum = m.SourceChecksum

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		IsStableRevision *bool `json:"is_stable_revision,omitempty"`

		ProvidedFeatures []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 `json:"provided_features"`
	}

	dataAO1.IsStableRevision = m.IsStableRevision

	dataAO1.ProvidedFeatures = m.ProvidedFeatures

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencySets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatformSourceURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvidedFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3) validateDependencySets(formats strfmt.Registry) error {

	if swag.IsZero(m.DependencySets) { // not required
		return nil
	}

	for i := 0; i < len(m.DependencySets); i++ {
		if swag.IsZero(m.DependencySets[i]) { // not required
			continue
		}

		if m.DependencySets[i] != nil {
			if err := m.DependencySets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependency_sets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3) validatePlatformSourceURI(formats strfmt.Registry) error {

	if swag.IsZero(m.PlatformSourceURI) { // not required
		return nil
	}

	if err := validate.FormatOf("platform_source_uri", "body", "uri", m.PlatformSourceURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3) validateProvidedFeatures(formats strfmt.Registry) error {

	if err := validate.Required("provided_features", "body", m.ProvidedFeatures); err != nil {
		return err
	}

	for i := 0; i < len(m.ProvidedFeatures); i++ {
		if swag.IsZero(m.ProvidedFeatures[i]) { // not required
			continue
		}

		if m.ProvidedFeatures[i] != nil {
			if err := m.ProvidedFeatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("provided_features" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 dependency sets items0
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0 struct {

	// dependencies
	// Required: true
	// Min Items: 1
	Dependencies []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0 `json:"dependencies"`

	// A description of this set.
	Description string `json:"description,omitempty"`

	// Whatever text or metadata was parsed to create this set.
	OriginalRequirement string `json:"original_requirement,omitempty"`

	// Recipe
	//
	// The different types of dependencies supported by the platform.
	// Required: true
	// Enum: [build runtime test]
	Type *string `json:"type"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 dependency sets items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDependencies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) validateDependencies(formats strfmt.Registry) error {

	if err := validate.Required("dependencies", "body", m.Dependencies); err != nil {
		return err
	}

	iDependenciesSize := int64(len(m.Dependencies))

	if err := validate.MinItems("dependencies", "body", iDependenciesSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.Dependencies); i++ {
		if swag.IsZero(m.Dependencies[i]) { // not required
			continue
		}

		if m.Dependencies[i] != nil {
			if err := m.Dependencies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependencies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["build","runtime","test"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTypePropEnum = append(v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTypePropEnum, v)
	}
}

const (

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeBuild captures enum value "build"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeBuild string = "build"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeRuntime captures enum value "runtime"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeRuntime string = "runtime"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTest captures enum value "test"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTest string = "test"
)

// prop value enum
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0TypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0 Dependency
//
// A single dependency for an ingredient version revision
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0 struct {

	// The features that must already be present in the recipe for this requirement to apply. For example, can be used to create requirements that only apply on specific operating systems.
	Conditions []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0 `json:"conditions"`

	// The name of the feature this ingredient version is dependent on
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the feature depended on is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Whatever text or data structure we parsed to generate this dependency
	OriginalRequirement string `json:"original_requirement,omitempty"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0 v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 conditions items0
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`

	// Whatever text or data structure we parsed to generate this condition
	OriginalCondition string `json:"original_condition,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		Namespace *string `json:"namespace"`

		Requirements []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.Namespace = dataAO0.Namespace

	m.Requirements = dataAO0.Requirements

	// AO1
	var dataAO1 struct {
		OriginalCondition string `json:"original_condition,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.OriginalCondition = dataAO1.OriginalCondition

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		Namespace *string `json:"namespace"`

		Requirements []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.Namespace = m.Namespace

	dataAO0.Requirements = m.Requirements

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		OriginalCondition string `json:"original_condition,omitempty"`
	}

	dataAO1.OriginalCondition = m.OriginalCondition

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 conditions items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 conditions items0 requirements items0
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 conditions items0 requirements items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0 v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 requirements items0
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 dependency sets items0 dependencies items0 requirements items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum = append(v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorEq string = "eq"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGt string = "gt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorGte string = "gte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLt string = "lt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorLte string = "lte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3DependencySetsItems0DependenciesItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 Provided Feature
//
// A feature that is provided by a revisioned resource
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0 struct {

	// feature
	// Required: true
	Feature *string `json:"feature"`

	// If this is true then it means that we assigned a version to this feature ourselves rather than getting it directly from metadata in the source ingredient.
	IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

	// Whether the provider of this feature is the default provider. There can only be one default provider per feature namespace, name, and version.
	// Required: true
	IsDefaultProvider *bool `json:"is_default_provider"`

	// namespace
	// Required: true
	Namespace *string `json:"namespace"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Required: true
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The canonical version string for the resource. Should be as specific as possible (e.g. '10.9.6' of macOS instead of just '10.9'). May contain non-numeric version segments and other formatting characters if necessary.
	// Required: true
	Version *string `json:"version"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Feature = dataAO0.Feature

	m.IsActivestateVersion = dataAO0.IsActivestateVersion

	m.IsDefaultProvider = dataAO0.IsDefaultProvider

	m.Namespace = dataAO0.Namespace

	// AO1
	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.SortableVersion = dataAO1.SortableVersion

	m.Version = dataAO1.Version

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Feature *string `json:"feature"`

		IsActivestateVersion *bool `json:"is_activestate_version,omitempty"`

		IsDefaultProvider *bool `json:"is_default_provider"`

		Namespace *string `json:"namespace"`
	}

	dataAO0.Feature = m.Feature

	dataAO0.IsActivestateVersion = m.IsActivestateVersion

	dataAO0.IsDefaultProvider = m.IsDefaultProvider

	dataAO0.Namespace = m.Namespace

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		SortableVersion []string `json:"sortable_version"`

		Version *string `json:"version"`
	}

	dataAO1.SortableVersion = m.SortableVersion

	dataAO1.Version = m.Version

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 ingredient version all of3 provided features items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDefaultProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateIsDefaultProvider(formats strfmt.Registry) error {

	if err := validate.Required("is_default_provider", "body", m.IsDefaultProvider); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateSortableVersion(formats strfmt.Registry) error {

	if err := validate.Required("sortable_version", "body", m.SortableVersion); err != nil {
		return err
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0IngredientVersionAllOf3ProvidedFeaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0 Patch
//
// A diff of changes that can be applied to an ingredient's source code. This model contains all patch properties and is returned from read requests
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0 struct {

	// creation timestamp
	// Required: true
	// Format: date-time
	CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

	// links
	// Required: true
	Links *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links `json:"links"`

	// patch id
	// Required: true
	// Format: uuid
	PatchID *strfmt.UUID `json:"patch_id"`

	// The features that must already be present in the recipe for this patch to be used. For example, can be used to create patches that only work on specific operating systems.
	Conditions []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0 `json:"conditions"`

	// The patch itself
	// Required: true
	Content *string `json:"content"`

	// A concise summary of what this patch can be used for
	// Required: true
	Description *string `json:"description"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links `json:"links"`

		PatchID *strfmt.UUID `json:"patch_id"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.CreationTimestamp = dataAO0.CreationTimestamp

	m.Links = dataAO0.Links

	m.PatchID = dataAO0.PatchID

	// AO1
	var dataAO1 struct {
		Conditions []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0 `json:"conditions,omitempty"`

		Content *string `json:"content"`

		Description *string `json:"description"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Conditions = dataAO1.Conditions

	m.Content = dataAO1.Content

	m.Description = dataAO1.Description

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		CreationTimestamp *strfmt.DateTime `json:"creation_timestamp"`

		Links *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links `json:"links"`

		PatchID *strfmt.UUID `json:"patch_id"`
	}

	dataAO0.CreationTimestamp = m.CreationTimestamp

	dataAO0.Links = m.Links

	dataAO0.PatchID = m.PatchID

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	var dataAO1 struct {
		Conditions []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0 `json:"conditions,omitempty"`

		Content *string `json:"content"`

		Description *string `json:"description"`
	}

	dataAO1.Conditions = m.Conditions

	dataAO1.Content = m.Content

	dataAO1.Description = m.Description

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 patches items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreationTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePatchID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) validateCreationTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("creation_timestamp", "body", m.CreationTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("creation_timestamp", "body", "date-time", m.CreationTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) validateLinks(formats strfmt.Registry) error {

	if err := validate.Required("links", "body", m.Links); err != nil {
		return err
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) validatePatchID(formats strfmt.Registry) error {

	if err := validate.Required("patch_id", "body", m.PatchID); err != nil {
		return err
	}

	if err := validate.FormatOf("patch_id", "body", "uuid", m.PatchID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) validateConditions(formats strfmt.Registry) error {

	if swag.IsZero(m.Conditions) { // not required
		return nil
	}

	for i := 0; i < len(m.Conditions); i++ {
		if swag.IsZero(m.Conditions[i]) { // not required
			continue
		}

		if m.Conditions[i] != nil {
			if err := m.Conditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("conditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) validateContent(formats strfmt.Registry) error {

	if err := validate.Required("content", "body", m.Content); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links Self Link
//
// A self link
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links struct {

	// The URI of this resource
	// Required: true
	// Format: uri
	Self *strfmt.URI `json:"self"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 patches items0 a o0 links
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links) validateSelf(formats strfmt.Registry) error {

	if err := validate.Required("links"+"."+"self", "body", m.Self); err != nil {
		return err
	}

	if err := validate.FormatOf("links"+"."+"self", "body", "uri", m.Self.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0AO0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0 Condition Sub Schema
//
// A feature that must be present in a recipe for the containing entity to apply. If nothing in the recipe matches this condition, the containing entity is disable/cannot be used.
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0 struct {

	// What feature must be present for the containing entity to apply
	// Required: true
	Feature *string `json:"feature"`

	// The namespace the conditional feature is contained in
	// Required: true
	Namespace *string `json:"namespace"`

	// Requirements Sub Schema
	//
	// The version constraints that an ingredient version's requirement or condition puts on a feature
	// Required: true
	// Min Length: 1
	Requirements []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0 `json:"requirements"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 patches items0 conditions items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0) validateRequirements(formats strfmt.Registry) error {

	if err := validate.Required("requirements", "body", m.Requirements); err != nil {
		return err
	}

	for i := 0; i < len(m.Requirements); i++ {
		if swag.IsZero(m.Requirements[i]) { // not required
			continue
		}

		if m.Requirements[i] != nil {
			if err := m.Requirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0 v1 recipe response recipes items0 resolved ingredients items0 patches items0 conditions items0 requirements items0
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0 struct {

	// The operator used to compare the sortable_version against a given provided feature to determine if it meets the requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// An array of decimal values representing all segments of a version, ordered from most to least significant. How a version string is rendered into a list of decimals will vary depending on the format of the source string and is therefore left up to the caller, but it must be done consistently across all versions of the same resource for sorting to work properly. This is represented as a string to avoid losing precision when converting to a floating point number.
	// Min Length: 1
	SortableVersion []string `json:"sortable_version"`

	// The required version in its original form.
	// Min Length: 1
	Version *string `json:"version,omitempty"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 patches items0 conditions items0 requirements items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortableVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum = append(v1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorEq captures enum value "eq"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorEq string = "eq"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorGt captures enum value "gt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorGt string = "gt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorGte captures enum value "gte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorGte string = "gte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorLt captures enum value "lt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorLt string = "lt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorLte captures enum value "lte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorLte string = "lte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorNe captures enum value "ne"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) validateSortableVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.SortableVersion) { // not required
		return nil
	}

	for i := 0; i < len(m.SortableVersion); i++ {

		if err := validate.MinLength("sortable_version"+"."+strconv.Itoa(i), "body", string(m.SortableVersion[i]), 1); err != nil {
			return err
		}

	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0PatchesItems0ConditionsItems0RequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0 Requirement Sub Schema
//
// An order requirement is a single package name and version specifier requested in an order.
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0 struct {

	// The name of the required feature, If no ingredient ID is specified, the default provider of this feature will be chosen.
	// Required: true
	Feature *string `json:"feature"`

	// The ID of the ingredient version that should be used to fulfill this requirement. Can be used to override the default choice of provider for the specified feature. Must be an ingredient version that actually provides the specified feature.
	// Format: uuid
	IngredientVersionID strfmt.UUID `json:"ingredient_version_id,omitempty"`

	// The namespace for the required feature. For now, this can be empty as it is only used to request pre-platform installer ingredients.
	// Required: true
	Namespace *string `json:"namespace"`

	// The requirements for the acceptable versions of this feature. This can be omitted, in which case any version is acceptable.
	// Min Items: 1
	VersionRequirements []*V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0 `json:"version_requirements"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 resolved requirements items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIngredientVersionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNamespace(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersionRequirements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0) validateFeature(formats strfmt.Registry) error {

	if err := validate.Required("feature", "body", m.Feature); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0) validateIngredientVersionID(formats strfmt.Registry) error {

	if swag.IsZero(m.IngredientVersionID) { // not required
		return nil
	}

	if err := validate.FormatOf("ingredient_version_id", "body", "uuid", m.IngredientVersionID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0) validateNamespace(formats strfmt.Registry) error {

	if err := validate.Required("namespace", "body", m.Namespace); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0) validateVersionRequirements(formats strfmt.Registry) error {

	if swag.IsZero(m.VersionRequirements) { // not required
		return nil
	}

	iVersionRequirementsSize := int64(len(m.VersionRequirements))

	if err := validate.MinItems("version_requirements", "body", iVersionRequirementsSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.VersionRequirements); i++ {
		if swag.IsZero(m.VersionRequirements[i]) { // not required
			continue
		}

		if m.VersionRequirements[i] != nil {
			if err := m.VersionRequirements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("version_requirements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0 Version Requirement Sub Schema
//
// The version constraint for a feature
// swagger:model V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0
type V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0 struct {

	// The operator used to compare the version against a given provided feature to determine if it meets this requirement
	// Required: true
	// Enum: [eq gt gte lt lte ne]
	Comparator *string `json:"comparator"`

	// The required version in its original form
	// Required: true
	// Min Length: 1
	Version *string `json:"version"`
}

// Validate validates this v1 recipe response recipes items0 resolved ingredients items0 resolved requirements items0 version requirements items0
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComparator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var v1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0TypeComparatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["eq","gt","gte","lt","lte","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0TypeComparatorPropEnum = append(v1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0TypeComparatorPropEnum, v)
	}
}

const (

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorEq captures enum value "eq"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorEq string = "eq"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorGt captures enum value "gt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorGt string = "gt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorGte captures enum value "gte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorGte string = "gte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorLt captures enum value "lt"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorLt string = "lt"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorLte captures enum value "lte"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorLte string = "lte"

	// V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorNe captures enum value "ne"
	V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0ComparatorNe string = "ne"
)

// prop value enum
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) validateComparatorEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, v1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0TypeComparatorPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) validateComparator(formats strfmt.Registry) error {

	if err := validate.Required("comparator", "body", m.Comparator); err != nil {
		return err
	}

	// value enum
	if err := m.validateComparatorEnum("comparator", "body", *m.Comparator); err != nil {
		return err
	}

	return nil
}

func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	if err := validate.MinLength("version", "body", string(*m.Version), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0) UnmarshalBinary(b []byte) error {
	var res V1RecipeResponseRecipesItems0ResolvedIngredientsItems0ResolvedRequirementsItems0VersionRequirementsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
