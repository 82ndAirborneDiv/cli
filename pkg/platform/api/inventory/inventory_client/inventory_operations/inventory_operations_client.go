// Code generated by go-swagger; DO NOT EDIT.

package inventory_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new inventory operations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for inventory operations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
HealthCheck health check API
*/
func (a *Client) HealthCheck(params *HealthCheckParams) (*HealthCheckOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHealthCheckParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "healthCheck",
		Method:             "GET",
		PathPattern:        "/health-check",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &HealthCheckReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*HealthCheckOK), nil

}

/*
Ingredient ingredient API
*/
func (a *Client) Ingredient(params *IngredientParams) (*IngredientOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIngredientParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ingredient",
		Method:             "GET",
		PathPattern:        "/ingredients/{ingredient_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IngredientReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*IngredientOK), nil

}

/*
IngredientVersions ingredient versions API
*/
func (a *Client) IngredientVersions(params *IngredientVersionsParams) (*IngredientVersionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIngredientVersionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ingredientVersions",
		Method:             "GET",
		PathPattern:        "/ingredients/{ingredient_id}/versions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IngredientVersionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*IngredientVersionsOK), nil

}

/*
Ingredients ingredients API
*/
func (a *Client) Ingredients(params *IngredientsParams) (*IngredientsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIngredientsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ingredients",
		Method:             "GET",
		PathPattern:        "/ingredients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IngredientsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*IngredientsOK), nil

}

/*
LanguageIngredients alls ingredients for a language version

Retrieves all ingredients for a given version of a language
*/
func (a *Client) LanguageIngredients(params *LanguageIngredientsParams) (*LanguageIngredientsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLanguageIngredientsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "languageIngredients",
		Method:             "GET",
		PathPattern:        "/languages/{name}/{version}/ingredients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &LanguageIngredientsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LanguageIngredientsOK), nil

}

/*
Languages alls languages

Retrieves all languages
*/
func (a *Client) Languages(params *LanguagesParams) (*LanguagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLanguagesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "languages",
		Method:             "GET",
		PathPattern:        "/languages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &LanguagesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LanguagesOK), nil

}

/*
OrderRecipes recipes for an order

Solve the order's requirements into concrete ingredient versions and return one or more recipes fulfilling the order
*/
func (a *Client) OrderRecipes(params *OrderRecipesParams) (*OrderRecipesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOrderRecipesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "orderRecipes",
		Method:             "POST",
		PathPattern:        "/orders/{orderId}/recipes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OrderRecipesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*OrderRecipesOK), nil

}

/*
Platforms alls platforms

Retrieves all platforms
*/
func (a *Client) Platforms(params *PlatformsParams) (*PlatformsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPlatformsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "platforms",
		Method:             "GET",
		PathPattern:        "/platforms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PlatformsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PlatformsOK), nil

}

/*
ReadinessCheck readiness check API
*/
func (a *Client) ReadinessCheck(params *ReadinessCheckParams) (*ReadinessCheckOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReadinessCheckParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "readinessCheck",
		Method:             "GET",
		PathPattern:        "/readiness-check",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReadinessCheckReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ReadinessCheckOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
